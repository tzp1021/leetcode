//===========================Distinct Subsequences============================//
class Solution {
public:
    int numDistinct(string S, string T) {
        // Start typing your C/C++ solution below
        // DO NOT write int main() function
        int len1=S.length();
        int len2=T.length();
        int **dp = new int*[len1+1];
        for(int i=0;i<=len1;i++)
            dp[i]= new int[len2+1];
        for(int j=len2;j>=0;j--){
            dp[len1][j]=0;
        }
        for(int i=len1;i>=0;i--){
            dp[i][len2]=1;
        }
        for(int i=len1-1;i>=0;i--){
            for(int j=len2-1;j>=0;j--){
                dp[i][j]=dp[i+1][j];
                if(S[i]==T[j])
                    dp[i][j]+=dp[i+1][j+1];
            }
        }
        return dp[0][0];
    }
};
//============================Search a 2D Matrix===============================//
class Solution {
public:
    bool searchMatrix(vector<vector<int> > &matrix, int target) {
        // Start typing your C/C++ solution below
        // DO NOT write int main() function
        int height=matrix.size();
        int length=matrix[0].size();
        int i=0,j=height-1;
        while(i<=j){
            int tmp=matrix[(i+j)/2][0];
            if(tmp==target)
                return true;
            if(tmp<target)
                i=(i+j)/2+1;
            else
                j=(i+j)/2-1;
        }
        if(j<0)
            return false;
        int ii=0,jj=length-1;
        while(ii<=jj){
            int tmp=matrix[j][(ii+jj)/2];
            if(tmp==target)
                return true;
            if(tmp<target)
                ii=(ii+jj)/2+1;
            else
                jj=(ii+jj)/2-1;
        }
        return false;
    }
};
//============================Search for a Range===================================//
class Solution {
public:
    vector<int> searchRange(int A[], int n, int target) {
        // Start typing your C/C++ solution below
        // DO NOT write int main() function
        int i=0,j=n-1;
        while(i<=j){
            int mid=(i+j)/2;
            if(A[mid]<=target)
                i=mid+1;
            else
                j=mid-1;
        }
        int ii=0,jj=n-1;
        while(ii<=jj){
            int mid=(ii+jj)/2;
            if(A[mid]<target)
                ii=mid+1;
            else
                jj=mid-1;
        }
        vector<int> ans;
        if(i-jj>1){
            ans.push_back(jj+1);
            ans.push_back(i-1);
        }
        else{
            ans.push_back(-1);
            ans.push_back(-1);
        }
        return ans;
    }
};
//===========================Search in Rotated Sorted Array================================//
class Solution {
public:
    int search(int A[], int n, int target) {
        // Start typing your C/C++ solution below
        // DO NOT write int main() function
        int i=0,j=n-1;
        while(i<j-1){
            int mid=(i+j)/2;
            if(A[mid]>=A[i])
                i=mid;
            else
                j=mid;
        }
        if(A[i]<=A[j]){
            i++;
            j++;
        }
        //i is the max, j is the min
        int ii,jj;
        if(A[0]>target){
            ii=j;
            jj=n-1;
        }
        else{
            ii=0;
            jj=i;
        }
        while(ii<=jj){
            int mid=(ii+jj)/2;
            if(A[mid]==target)
                return mid;
            if(A[mid]<target)
                ii=mid+1;
            else
                jj=mid-1;
        }
        return -1;
    }
};
//===========================Longest Palindromic Substring============================//
class Solution {
public:
    string preProcess(string s) {
        int len = (int)s.length();
        if(len == 0)
            return "^$";
        string ret = "^";
        for(int i = 0; i < len; i++) {
            ret += "#" + s.substr(i, 1);
        }
        ret += "#$";
        return ret;
    }
    
    string longestPalindrome(string s) {
        string str = preProcess(s);
        int len = (int)str.length();
        int max_pos = 0;
        int max_pos_right = 0;
        int* radius = new int[len];
        memset(radius, 0, len);
        
        for(int i = 1; i < len - 1; i++) {
            int i_mirror = 2 * max_pos - i;
            radius[i] = (max_pos_right > i) ? min(max_pos_right - i, radius[i_mirror]) : 0;
            
            while (str[i + 1 + radius[i]] == str[i - 1 - radius[i]]) {
                radius[i]++;
            }
            
            if(i + radius[i] > max_pos_right) {
                max_pos_right = i + radius[i];
                max_pos = i;
            }
        }
        
        int ans_pos = 0;
        int ans_radius = 0;
        for(int i = 0; i < len - 1; i++) {
            if(radius[i] > ans_radius) {
                ans_pos = i;
                ans_radius = radius[i];
            }
        }
        
        delete[] radius;
        
        return s.substr((ans_pos - 1 - ans_radius) / 2, ans_radius);
    }
};
//===========================Median of Two Sorted Arrays============================//
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int len1 = (int) nums1.size();
        int len2 = (int) nums2.size();
        if(len1 < len2)
            return findMedianSortedArrays(nums2, nums1);
        
        int lo = 0, hi = len2 * 2;
        while(lo <= hi) {
            int mid2 = (lo + hi) / 2;
            int mid1 = len1 + len2 - mid2;
            
            int l1 = (mid1 == 0) ? INT_MIN : nums1[(mid1 - 1) / 2];
            int l2 = (mid2 == 0) ? INT_MIN : nums2[(mid2 - 1) / 2];
            int r1 = (mid1 == len1 * 2) ? INT_MAX : nums1[mid1 / 2];
            int r2 = (mid2 == len2 * 2) ? INT_MAX : nums2[mid2 / 2];
            
            if(l1 > r2) {
                lo = mid2 + 1;
            } else if(l2 > r1) {
                hi = mid2 - 1;
            } else {
                return (max(l1, l2) + min(r1, r2)) / 2.0;
            }
        }
        return -1;
    }
};
//===========================Kth Largest Element in an Array============================//
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        if(k > nums.size())
            return -1;
        return findKthMin(nums, 0, (int)nums.size() - 1, (int)nums.size() - k);
    }
    
    int findKthMin(vector<int>& nums, int start, int end, int k) {
        if(start > end)
            return 0;
        
        int i = start + 1, j = end;
        while(i <= j) {
            while(i <= j && nums[i] <= nums[start])
                i++;
            while (i <= j && nums[j] >= nums[start])
                j--;
            if(i < j)
                swap(nums[i++], nums[j--]);
        }
        swap(nums[start], nums[j]);
        
        if(j > k)
            return findKthMin(nums, start, j - 1, k);
        else if(j < k)
            return findKthMin(nums, j + 1, end, k);
        else
            return nums[j];
        
        return 0;
    }
};
//===========================79. Word Search============================//
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        for(int i = 0; i < board.size(); i++) {
            for(int j = 0; j < board[0].size(); j++) {
                if(dfs(board, word, i, j, 0))
                    return true;
            }
        }
        return false;
    }
    
    bool dfs(vector<vector<char>>& board, string& word, int i, int j, int idx) {
        if(idx == word.length())
            return true;
        if(i < 0 || i >= board.size() || j < 0 || j >= board[0].size() || board[i][j] != word[idx])
            return false;
        board[i][j] = '*';
        bool ret = dfs(board, word, i, j + 1, idx + 1)
                    || dfs(board, word, i, j - 1, idx + 1)
                    || dfs(board, word, i - 1, j, idx + 1)
                    || dfs(board, word, i + 1, j, idx + 1);
        board[i][j] = word[idx];
        return ret;
    }
};
//===========================8. String to Integer (atoi)============================//
class Solution {
public:
    int myAtoi(string str) {
        if(str.empty())
            return 0;
        int idx = 0, sign = 1;
        long long ret = 0;
        while(idx < str.length() && str[idx] == ' ')
            idx++;
        if(str[idx] == '-' || str[idx] == '+') {
            sign = (str[idx] == '-') ? -1 : 1;
            idx++;
        }
        while(idx < str.length() && str[idx] >= '0' && str[idx] <= '9') {
            ret = ret * 10 + str[idx] - '0';
            if(ret * sign >= INT_MAX) {
                return INT_MAX;
            } else if (ret * sign <= INT_MIN) {
                return INT_MIN;
            }
            idx++;
        }
        return (int)ret * sign;
    }
};
//===========================32. Longest Valid Parentheses============================//
class Solution {
public:
    int longestValidParentheses(string s) {
        vector<int> stack;
        int ret = 0, start = -1;
        for(int i = 0; i < s.length(); i++) {
            if(s[i] == '(')
                stack.push_back(i);
            if(s[i] == ')') {
                if(stack.empty()) {
                    start = i;
                }
                else {
                    stack.pop_back();
                    ret = (stack.empty()) ? max(ret, i - start) : max(ret, i - stack.back());
                }
            }
        }
        return ret;
    }
};
//===========================29. Divide Two Integers============================//
class Solution {
public:
    int divide(int dividend, int divisor) {
        if(divisor == 0 || dividend == 0)
            return 0;
        if(dividend == INT_MIN && divisor == -1)
            return INT_MAX;
        bool is_minus = (dividend < 0) ^ (divisor < 0);
        int ret = 0;
        int bits = 0;
        dividend = (dividend > 0) ? dividend : -dividend;
        divisor = (divisor > 0) ? divisor: -divisor;
        while(divisor > dividend && divisor >= 0xc0000000) {
            bits++;
            divisor <<= 1;
        }
        if(divisor < dividend) {
            bits--;
            divisor >>= 1;
        }
        while(dividend != 0 && bits >= 0) {
            if(dividend <= divisor) {
                dividend -= divisor;
                ret += 1 << bits;
            }
            divisor >>= 1;
            bits--;
        }
        ret = is_minus ? -ret: ret;
        return ret;
    }
};
//===========================127. Word Ladder============================//
class Solution {
public:
    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {
        unordered_set<string> wordDict(wordList.begin(), wordList.end());
        if(wordDict.find(endWord) == wordDict.end())
            return 0;
        queue<string> toVisit;
        toVisit.push(beginWord);
        int ret = 1;
        while(!toVisit.empty()) {
            for(int i = (int)toVisit.size(); i > 0; i--) {
                string word = toVisit.front();
                toVisit.pop();
                if(word == endWord)
                    return ret;
                addNextWord(word, wordDict, toVisit);
            }
            ret++;
        }
        
        return 0;
    }
    void addNextWord(string word, unordered_set<string>& wordDict, queue<string>& toVisit) {
        for(int i = 0; i < word.length(); i++) {
            char letter = word[i];
            for(int j = 0; j < 26; j++) {
                word[i] = 'a' + j;
                if(wordDict.find(word) != wordDict.end()) {
                    toVisit.push(word);
                    wordDict.erase(word);
                }
            }
            word[i] = letter;
        }
    }
};
//===========================126. Word Ladder II============================//
class Solution {
public:
    vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {
        vector<vector<string>> ret;
        unordered_set<string> wordDict(wordList.begin(), wordList.end());
        if(wordDict.find(endWord) == wordDict.end())
            return ret;
        queue<vector<string>> toVisit;
        queue<string> toErase;
        vector<string> beginPath;
        beginPath.push_back(beginWord);
        toVisit.push(beginPath);
        bool isFound = false;
        while(!toVisit.empty() && !isFound) {
            for(int i = (int)toVisit.size(); i > 0; i--) {
                vector<string> path = toVisit.front();
                string word = path.back();
                toVisit.pop();
                if(word == endWord) {
                    ret.push_back(path);
                    isFound = true;
                }
                addNextPath(path, wordDict, toVisit, toErase);
            }
            for(int i = (int)toErase.size(); i > 0; i--) {
                string word = toErase.front();
                toErase.pop();
                wordDict.erase(word);
            }
        }
        return ret;
    }
    
    void addNextPath(vector<string>& path, unordered_set<string>& wordDict, queue<vector<string>>& toVisit, queue<string>& toErase) {
        string word = path.back();
        for(int i = 0; i < word.length(); i++) {
            char letter = word[i];
            for(int j = 0; j < 26; j++) {
                word[i] = 'a' + j;
                if(wordDict.find(word) != wordDict.end()) {
                    vector<string> new_path = path;
                    new_path.push_back(word);
                    toVisit.push(new_path);
                    toErase.push(word);
                }
            }
            word[i] = letter;
        }
    }
};
//===========================146. LRU Cache============================//
struct Node {
    Node(int key_, int value_) {
        key = key_;
        value = value_;
    }
    int key;
    int value;
};
class LRUCache {
public:
    LRUCache(int capacity) : SIZE(capacity) {
    }
    
    int get(int key) {
        auto ret = map_.find(key);
        if(ret != map_.cend()) {
            moveToHead(ret->second);
            return ret->second->value;
        }
        return -1;
    }
    
    void put(int key, int value) {
        auto ret = map_.find(key);
        if(ret == map_.cend()) {
            list_.emplace_front(key, value);
            map_[key] = list_.begin();
            if(list_.size() > SIZE) {
                auto remove = list_.back();
                map_.erase(remove.key);
                list_.pop_back();
            }
        } else {
            moveToHead(ret->second);
            list_.front().value = value;
        }
    }
    
    void moveToHead(std::list<Node>::iterator node) {
        list_.emplace_front(node->key, node->value);
        map_[node->key] = list_.begin();
        list_.erase(node);
    }
private:
    list<Node> list_;
    unordered_map<int, decltype(list_)::iterator> map_;
    int SIZE;
};
//===========================202. Happy Number============================//
class Solution {
public:
    bool isHappy(int n) {
        while(true) {
            if(_set.find(n) != _set.end())
                break;
            _set.insert(n);
            int sum = 0;
            while(n) {
                int tmp = n % 10;
                sum += tmp * tmp;
                n /= 10;
            }
            if(sum == 1)
                return true;
            n = sum;
        }
        return false;
    }
private:
    set<int> _set;
};
//===========================216. Combination Sum III============================//
class Solution {
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        vector<vector<int>> ans;
        for(int i = 1; i <= 9; i++) {
            vector<int> vec;
            vec.push_back(i);
            combinationSum3(k-1, n-i, vec, ans);
            vec.pop_back();
        }
        return ans;
    }
    
private:
    void combinationSum3(int k, int n, vector<int> &vec, vector<vector<int>> &ans) {
        if(k == 0 && n == 0) {
            ans.push_back(vec);
            return;
        }
        if(k == 0 || n == 0) {
            return;
        }
        for(int i = vec.back() + 1; i <= 9; i++) {
            vec.push_back(i);
            combinationSum3(k-1, n-i, vec, ans);
            vec.pop_back();
        }
    }
};
//===========================135. Candy============================//
class Solution {
public:
    int candy(vector<int>& ratings) {
        if(ratings.size() == 0)
            return 0;
        int ret = 1;
        int idx = 0;
        int idx_num = 1;
        int last_num = 1;
        for(int i = 1; i < ratings.size(); i++) {
            if(ratings[i] > ratings[i-1]) {
                idx = i;
                last_num++;
                idx_num = last_num;
                ret += last_num;
            } else if(ratings[i] < ratings[i-1]) {
                last_num = 1;
                if(idx_num >= i - idx + 1) {
                    ret += i - idx;
                } else {
                    ret += i - idx + 1;
                }
            } else {
                idx = i;
                last_num = 1;
                idx_num = 1;
                ret += 1;
            }
        }
        return ret;
    }
};
//===========================143. Reorder List============================//
class Solution {
public:
    void reorderList(ListNode* head) {
        if(head == NULL)
            return;
        vector<ListNode*> vec;
        vec.push_back(head);
        while(head->next != NULL) {
            head = head->next;
            vec.push_back(head);
        }
        int i = 0;
        int j = vec.size() - 1;
        bool flag = true;
        while(i < j) {
            if(flag)
                vec[i++]->next = vec[j];
            else
                vec[j--]->next = vec[i];
            flag = !flag;
        }
        vec[j]->next = NULL;
    }
};
//130. Surrounded Regions
class Solution {
public:
    void solve(vector<vector<char>>& board) {
        if(board.size() == 0)
            return;
        int m = (int)board.size();
        int n = (int)board[0].size();
        bool* flags = new bool[m * n];
        memset(flags, 0, m * n);
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                if(board[i][j] == 'O' && !flags[i * n + j]) {
                    bfs(i, j, board, flags);
                }
            }
        }
        delete [] flags;
    }
private:
    void bfs(int i, int j, vector<vector<char>>& board, bool flags[]) {
        int m = (int)board.size();
        int n = (int)board[0].size();
        vector<pair<int, int>> vec;
        vec.emplace_back(i, j);
        queue<pair<int,int>> q;
        q.emplace(i, j);
        flags[i * n + j] = false;
        bool isChange = true;
        int xx[] = {0, 0, -1, 1};
        int yy[] = {-1, 1, 0, 0};
        while(!q.empty()) {
            pair<int, int> p = q.front();
            q.pop();
            if(p.first == 0 || p.first == m - 1 || p.second == 0 || p.second == n - 1)
                isChange = false;
            for(int k = 0; k < 4; k++) {
                int ii = p.first + xx[k];
                int jj = p.second + yy[k];
                if(ii >= 0 && ii < m && jj >= 0 && jj < n && board[ii][jj] == 'O'
                   && !flags[ii * n + jj]) {
                    flags[ii * n + jj] = true;
                    vec.emplace_back(ii, jj);
                    q.emplace(ii, jj);
                }
            }
        }
        if(isChange) {
            for(int ii = 0; ii < vec.size(); ii++) {
                pair<int, int> p = vec[ii];
                board[p.first][p.second] = 'X';
            }
        }
    }
};
//132. Palindrome Partitioning II
class Solution {
public:
    int minCut(string s) {
        int n = (int)s.size();
        vector<int> dp(n, INT_MAX);
        vector<vector<bool>> isPalindrome(n, vector<bool>(n, false));
        dp[0] = 0;
        for(int i = 1; i < n; i++) {
            for(int j = 0; j <= i; j++) {
                if((i - j < 2 || isPalindrome[i-1][j+1]) && s[i] == s[j]) {
                    isPalindrome[i][j] = true;
                    dp[i] = min(dp[i], j == 0 ? 0 : dp[j - 1] + 1);
                }
            }
        }
        return dp[n - 1];
    }
};
//149. Max Points on a Line
class Solution {
public:
    int maxPoints(vector<Point>& points) {
        map<pair<int,int>, int> slopes;
        int ret = 0;
        int n = (int)points.size();
        for(int i = 0; i < n; i++) {
            slopes.clear();
            int duplicates = 1;
            for(int j = i + 1; j < n; j++) {
                if(points[i].x == points[j].x && points[i].y == points[j].y) {
                    duplicates++;
                    continue;
                }
                int dx = points[i].x - points[j].x;
                int dy = points[i].y - points[j].y;
                int g = gcd(dx, dy);
                slopes[make_pair(dx / g, dy / g)]++;
            }
            ret = max(ret, duplicates);
            for(auto slope : slopes) {
                ret = max(ret, slope.second + duplicates);
            }
        }
        return ret;
    }
private:
    int gcd(int a, int b) {
        while(b) {
            int tmp = b;
            b = a % b;
            a = tmp;
        }
        return a;
    }
};
//150. Evaluate Reverse Polish Notation
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        if(tokens.size() == 0)
            return 0;
        vector<int> vec;
        for(int i = 0; i < tokens.size(); i++) {
            if(tokens[i] == "+" || tokens[i] == "-" || tokens[i] == "*" || tokens[i] == "/") {
                int b = vec.back();
                vec.pop_back();
                int a = vec.back();
                vec.pop_back();
                if(tokens[i] == "+")
                    vec.emplace_back(a + b);
                if(tokens[i] == "-")
                    vec.emplace_back(a - b);
                if(tokens[i] == "*")
                    vec.emplace_back(a * b);
                if(tokens[i] == "/")
                    vec.emplace_back(a / b);
            } else {
                vec.emplace_back(atoi(tokens[i].c_str()));
            }
        }
        return vec.back();
    }
};

//139. Word Break
class Solution {
public:
    //40ms
    bool wordBreak(string s, unordered_set<string> &dict) {
        unordered_set<string> unmatch;
        return go(s, dict, unmatch);
    }
    bool go(string s, const unordered_set<string> &dict, unordered_set<string> &unmatch) {
        if(dict.find(s) != dict.end())
            return true;
        for(int i = 1; i <= s.size(); i++) {
            if(dict.find(s.substr(0, i)) != dict.end()) {
                if(unmatch.find(s.substr(i)) != unmatch.end())
                    continue;
                if(go(s.substr(i), dict, unmatch) == false)
                    unmatch.insert(s.substr(i));
                else
                    return true;
            }
        }
        return false;
    }
    //4ms
    bool wordBreak(string s, vector<string>& wordDict) {
        int len = (int)s.length();
        vector<bool> vec(len, false);
        for(int i = 0; i < len; i++) {
            for(int j = 0; j < wordDict.size(); j++) {
                string word = wordDict[j];
                int n = (int)wordDict[j].length();
                string str;
                if(i + 1 >= n)
                    str = s.substr(i + 1 - n, n);
                if(i + 1 >= n && s.substr(i + 1 - n, n) == wordDict[j]) {
                    if(i - n < 0 || vec[i-n])
                        vec[i] = true;
                }
            }
        }
        bool ret = vec[len - 1];
        return vec[len - 1];
    }
};
//140. Word Break II
class Solution {
public:
    vector<string> wordBreak(string s, vector<string>& wordDict) {
        int len = (int)s.length();
        vector<vector<int>> vec(len);
        for(int i = 0; i < len; i++) {
            for(int j = 0; j < wordDict.size(); j++) {
                int n = (int)wordDict[j].length();
                if(i + 1 >= n && s.substr(i + 1 - n, n) == wordDict[j]
                   && (i - n < 0 || !vec[i - n].empty())) {
                    vec[i].emplace_back(i-n);
                }
            }
        }
        vector<string> ret;
        dfs(vec, s, len - 1, "", ret);
        return ret;
    }
private:
    void dfs(vector<vector<int>>& vec, string& s, int n, string str, vector<string>& ret) {
        if(n == -1) {
            ret.emplace_back(str.substr(0, str.length() - 1));
            return;
        }
        for(int i = 0; i < vec[n].size(); i++) {
            dfs(vec, s, vec[n][i], s.substr(vec[n][i] + 1, n - vec[n][i]) + ' ' + str, ret);
        }
    }
};
//91. Decode Ways
class Solution {
public:
    int numDecodings(string s) {
        if(s.empty())
            return 0;
        int n = (int)s.length();
        vector<int> dp(n, 0);
        for(int i = 0; i < n; i++) {
            if(s[i] >= '1' && s[i] <= '9')
                dp[i] = i >= 1 ? dp[i - 1] : 1;
            if(i >= 1 && (s[i - 1] == '1' || (s[i-1] == '2' && s[i] <= '6'))) {
                dp[i] += i >= 2 ? dp[i - 2] : 1;
            }
        }
        return dp[n-1];
    }
};
//44. Wildcard Matching
class Solution {
public:
    bool isMatch(string s, string p) {
        int len1 = (int)s.length();
        int len2 = (int)p.length();
        vector<vector<bool>> dp(len1 + 1, vector<bool>(len2 + 1, false));
        dp[0][0] = true;
        for(int j = 1; j <= len2; j++) {
            if(p[j - 1] == '*' && dp[0][j-1])
                dp[0][j] = true;
        }
        for(int i = 1; i <= len1; i++) {
            for(int j = 1; j <= len2; j++) {
                if(p[j - 1] == '*') {
                    dp[i][j] = dp[i][j - 1] || dp[i - 1][j];
                } else if(p[j - 1] == '?' || p[j - 1] == s[i - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                }
            }
        }
        return dp[len1][len2];
    }
};
//10. Regular Expression Matching
class Solution {
public:
    bool isMatch(string s, string p) {
        int len1 = (int)s.length();
        int len2 = (int)p.length();
        vector<vector<bool>> dp(len1 + 1, vector<bool>(len2 + 1, false));
        dp[0][0] = true;
        for(int j = 1; j <= len2; j++) {
            if(j >= 2 && p[j - 1] == '*' && dp[0][j-2])
                dp[0][j] = true;
        }
        for(int i = 1; i <= len1; i++) {
            for(int j = 1; j <= len2; j++) {
                if(j >= 2 && p[j - 1] == '*') {
                    dp[i][j] = dp[i][j - 2];
                    if(p[j - 2] == '.' || p[j - 2] == s[i - 1]) {
                        dp[i][j] = dp[i][j] || dp[i -1][j];
                    }
                } else if(p[j - 1] == '.' || p[j - 1] == s[i - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                }
            }
        }
        return dp[len1][len2];
    }
};
//43. Multiply Strings
class Solution {
public:
    string multiply(string num1, string num2) {
        int len1 = (int)num1.length();
        int len2 = (int)num2.length();
        vector<int> vec(len1 + len2, 0);
        for(int i = 0; i < len1; i++) {
            for(int j = 0; j < len2; j++) {
                int idx = i + j;
                vec[idx] += (num1[len1 - i - 1] - '0') * (num2[len2 - j - 1] - '0');
                while(vec[idx] >= 10) {
                    vec[idx+1] += vec[idx] / 10;
                    vec[idx] %= 10;
                    idx++;
                }
            }
        }
        string ret;
        int k = len1 + len2 - 1;
        while(k > 0 && vec[k] == 0)
            k--;
        while(k >= 0)
            ret += '0' + vec[k--];
        return ret;
    }
};
//30. Substring with Concatenation of All Words
class Solution {
public:
    vector<int> findSubstring(string S, vector<string> &L) {
        vector<int> ret;
        if(S.length() == 0 || L.size() == 0 || L[0].length() == 0)
            return ret;
        int wordCount = (int)L.size();
        int wordLen = (int)L[0].length();
        int len = (int)S.length();
        unordered_map<string, queue<int>> wordHash;
        unordered_map<string, queue<int>>::iterator it;
        for(string str : L)
            wordHash[str].emplace(-1);
        for(int start = 0; start < wordLen; start++) {
            unordered_map<string, queue<int>> tmpWordHash = wordHash;
            int curCount = 0;
            for(int i = start; i < len; i += wordLen) {
                it = tmpWordHash.find(S.substr(i, wordLen));
                if(it == tmpWordHash.end()) {
                    curCount = 0;
                    continue;
                }
                int last_pos = it->second.front();
                if(last_pos == -1 || (i - last_pos) > curCount * wordLen)
                    curCount++;
                else
                    curCount = (i - last_pos) / wordLen;
                it->second.pop();
                it->second.emplace(i);
                if(curCount == wordCount)
                    ret.emplace_back(i - (wordCount - 1) * wordLen);
            }
        }
        return ret;
    }
};
//68. Text Justification
class Solution {
public:
    vector<string> fullJustify(vector<string>& words, int maxWidth) {
        vector<string> vec;
        vector<string> curLine;
        int curLineWidth = 0;
        for(int i = 0; i <= words.size(); i++) {
            if(i == words.size()) {
                string str;
                if(!curLine.empty())
                    str = curLine[0];
                for(int j = 1; j < curLine.size(); j++) {
                    str += ' ' + curLine[j];
                }
                for(size_t j = maxWidth - curLineWidth - curLine.size() + 1; j > 0; j--) {
                    str += ' ';
                }
                vec.emplace_back(str);
                break;
            }
            if(curLineWidth + words[i].length() + curLine.size() > maxWidth) {
                int space_width = curLine.size() == 1 ? maxWidth - curLineWidth : (maxWidth - curLineWidth) / (curLine.size() - 1);
                int mod = curLine.size() == 1 ? 0 : (maxWidth - curLineWidth) % (curLine.size() - 1);
                string str = curLine[0];
                for(int j = 1; j < curLine.size(); j++) {
                    for(int i = 0; i < space_width; i++)
                        str += ' ';
                    if(mod > 0) {
                        str += ' ';
                        mod--;
                    }
                    str += curLine[j];
                }
                if(curLine.size() == 1) {
                    for(int i = 0; i < space_width; i++)
                        str += ' ';
                }
                vec.emplace_back(str);
                curLine.clear();
                curLineWidth = 0;
            }
            curLine.emplace_back(words[i]);
            curLineWidth += words[i].length();
        }
        return vec;
    }
};
//71. Simplify Path
class Solution {
public:
    string simplifyPath(string path) {
        string ret;
        vector<string> vec;
        int i = 0;
        while(i < path.length()) {
            while(i < path.length() && path[i] == '/')
                i++;
            if(i == path.length())
                break;
            string str;
            while(i < path.length() && path[i] != '/')
                str += path[i++];
            if(str == ".." && !vec.empty())
                vec.pop_back();
            else if(str != "." && str != "..")
                vec.emplace_back(str);
        }
        for(string s : vec)
            ret += "/" + s;
        if(vec.empty())
            ret = "/";
        return ret;
    }
};
//97. Interleaving String
class Solution {
public:
    bool isInterleave(string s1, string s2, string s3) {
        if(s1.length() + s2.length() != s3.length())
            return false;
        vector<vector<bool>> dp(s1.length() + 1, vector<bool>(s2.length() + 1, false));
        dp[0][0] = true;
        for(int i = 0; i <= s1.length(); i++) {
            for(int j = 0; j <= s2.length(); j++) {
                if((j > 0 && dp[i][j - 1] && s2[j - 1] == s3[i + j - 1]) || (i > 0 && dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]))
                    dp[i][j] = true;
            }
        }
        return dp[s1.length()][s2.length()];
    }
};
//76. Minimum Window Substring
class Solution {
public:
    string minWindow(string s, string t) {
        string ret;
        unordered_map<char, int> hash;
        unordered_map<char, int>::iterator it;
        for(int i = 0; i < t.length(); i++)
            hash[t[i]]++;
        int start = 0, end = 0;
        int count = 0;
        while(end < s.length()) {
            while(count < t.length() && end < s.length()) {
                it = hash.find(s[end++]);
                if(it != hash.end()) {
                    if(it->second > 0)
                        count++;
                    it->second--;
                }
            }
            if(end == s.length() && count < t.length()) {
                break;
            }
            while(start <= end && count >= t.length()) {
                it = hash.find(s[start++]);
                if(it != hash.end()) {
                    if(it->second >= 0)
                        count--;
                    it->second++;
                }
            }
            if(ret.empty() || end - start + 1 < ret.length())
                ret = s.substr(start - 1, end - start + 1);
        }
        return ret;
    }
};
//93. Restore IP Addresses
class Solution {
public:
    vector<string> restoreIpAddresses(string s) {
        if(s.length() < 4)
            return vector<string>();
        int k = 4;
        vector<vector<vector<string>>> dp(s.length(), vector<vector<string>>(k));
        dp[0][0].emplace_back(s.substr(0, 1));
        if(s[0] != '0')
            dp[1][0].emplace_back(s.substr(0, 2));
        if(s[0] != '0' && atoi(s.substr(0, 3).c_str()) < 256)
            dp[2][0].emplace_back(s.substr(0, 3));
        for(int i = 1; i < s.length(); i++) {
            for(int j = 1; j < k; j++) {
                for(string str : dp[i - 1][j - 1]) {
                    str += "." + s.substr(i, 1);
                    dp[i][j].emplace_back(str);
                }
                if(i >= 2 && s[i- 1] != '0') {
                    for(string str : dp[i - 2][j - 1]) {
                        str += "." + s.substr(i - 1, 2);
                        dp[i][j].emplace_back(str);
                    }
                }
                if(i >= 3 && s[i- 2] != '0' && atoi(s.substr(i-2, 3).c_str()) < 256) {
                    for(string str : dp[i - 3][j - 1]) {
                        str += "." + s.substr(i - 2, 3);
                        dp[i][j].emplace_back(str);
                    }
                }
            }
        }
        return dp[s.length() - 1][k - 1];
    }
};
//154. Find Minimum in Rotated Sorted Array II
class Solution {
public:
    int findMin(vector<int>& nums) {
        int i = 0, j = (int)nums.size() - 1;
        while(i < j) {
            if(nums[i] == nums[j]) {
                while(i < j) {
                    if(nums[j] < nums[i])
                        return nums[j];
                    i++;
                }
                return nums[j];
            }
            if(nums[i] < nums[j])
                return nums[i];
            int mid = (i + j) / 2;
            if(nums[mid] >= nums[i])
                i = mid + 1;
            else
                j = mid;
        }
        return nums[i];
    }
};
//152. Maximum Product Subarray
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        if(nums.empty())
            return 0;
        int ret = nums[0];
        int maxx = nums[0];
        int minn = nums[0];
        for(int i = 1; i < nums.size(); i++) {
            int a = nums[i] * maxx;
            int b = nums[i] * minn;
            maxx = max(nums[i], max(a, b));
            minn = min(nums[i], min(a, b));
            if(ret < maxx)
                ret = maxx;
        }
        return ret;
    }
};
//155. Min Stack
class MinStack {
public:
    vector<int> vec;
    vector<int> mins;
    MinStack() {
        
    }
    
    void push(int x) {
        vec.emplace_back(x);
        mins.emplace_back(mins.empty() ? x : min(mins.back(), x));
    }
    
    void pop() {
        vec.pop_back();
        mins.pop_back();
    }
    
    int top() {
        return vec.back();
    }
    
    int getMin() {
        return mins.back();
    }
};
//160. Intersection of Two Linked Lists
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        int len1 = 0;
        int len2 = 0;
        ListNode* p1 = headA;
        ListNode* p2 = headB;
        while(p1) {
            p1 = p1->next;
            len1++;
        }
        while(p2) {
            p2 = p2->next;
            len2++;
        }
        if(len1 >= len2) {
            p1 = headA;
            p2 = headB;
        } else {
            p1 = headB;
            p2 = headA;
            swap(len1, len2);
        }
        for(int i = 0; i < len1 - len2; i++)
            p1 = p1->next;
        for(int i = 0; i < len2; i++) {
            if(p1 == p2)
                return p1;
            p1 = p1->next;
            p2 = p2->next;
        }
        return NULL;
    }
};
//162. Find Peak Element
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        if(nums.empty()) return -1;
        int len = (int)nums.size();
        if(len == 1) return 0;
        if(nums[0] > nums[1]) return 0;
        if(nums[len - 1] > nums[len - 2]) return len - 1;
        for(int i = 1; i < len - 1; i++) {
            if(nums[i] > nums[i + 1])
                return i;
        }
        return len - 1;
    }
};
//167. Two Sum II - Input array is sorted
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int i = 0, j = (int)numbers.size() - 1;
        vector<int> vec;
        while(i < j) {
            int sum = numbers[i] + numbers[j];
            if(sum == target) {
                vec.emplace_back(i + 1);
                vec.emplace_back(j + 1);
                return vec;
            }
            if(sum > target)
                j--;
            else
                i++;
        }
        return vec;
    }
};
//166. Fraction to Recurring Decimal
class Solution {
public:
    string fractionToDecimal(int numerator, int denominator) {
        string ret;
        long long a = numerator;
        long long b = denominator;
        if(a < 0 ^ b < 0)
            ret = "-";
        if(a < 0)
            a = -a;
        if(b < 0)
            b = -b;
        long long c = a / b;
        a = a - b * c;
        char buffer [33];
        sprintf(buffer, "%lld", c);
        ret += buffer;
        if(a > 0) {
            ret += ".";
            int idx = (int)ret.length();
            unordered_map<long long, long long> map;
            a *= 10;
            while(a && map.find(a) == map.end()) {
                map[a] = idx;
                idx++;
                c = a / b;
                a = a - b * c;
                a *= 10;
                sprintf(buffer, "%lld", c);
                ret += buffer;
            }
            if(a) {
                auto it = map.find(a);
                ret.insert(it->second, "(");
                ret += ")";
            }
        }
        return ret;
    }
};
//165. Compare Version Numbers
class Solution {
public:
    int compareVersion(string version1, string version2) {
        int v1;
        int v2;
        while(!version1.empty() || !version2.empty()) {
            v1 = getNum(version1);
            v2 = getNum(version2);
            if(v1 < v2)
                return -1;
            if(v1 > v2)
                return 1;
        }
        return 0;
    }
private:
    int getNum(string& str) {
        int num = 0;
        int i;
        for(i = 0; i < str.length(); i++) {
            if(str[i] == '.')
                break;
            num = num * 10 + str[i] - '0';
        }
        if(i < str.length())
            str = str.substr(i + 1);
        else
            str = str.substr(i);
        return num;
    }
};
//168. Excel Sheet Column Title
class Solution {
public:
    string convertToTitle(int n) {
        string ret;
        char c;
        while(n > 26) {
            int a = n / 26;
            int b = n % 26;
            if(b == 0) {
                b = 26;
                a--;
            }
            c =  'A' + b - 1;
            ret = c + ret;
            n = a;
        }
        c = 'A' + n - 1;
        ret = c + ret;
        return ret;
    }
};
//169. Majority Element
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int ret = 0;
        int count = 0;
        for(int num : nums) {
            if(count == 0) {
                count++;
                ret = num;
                continue;
            }
            if(num == ret)
                count++;
            else
                count--;
        }
        return ret;
    }
};
//172. Factorial Trailing Zeroes
class Solution {
public:
    int trailingZeroes(int n) {
        int ret = 0;
        while(n >= 5) {
            ret += n / 5;
            n /= 5;
        }
        return ret;
    }
};
//164. Maximum Gap
class Solution {
public:
    int maximumGap(vector<int>& nums) {
        if(nums.empty())
            return 0;
        int min_ = nums[0];
        int max_ = nums[0];
        for(int num : nums) {
            min_ = min(min_, num);
            max_ = max(max_, num);
        }
        if(max_ == min_)
            return 0;
        vector<vector<int>> bucket(nums.size());
        int gap = ceil((double)(max_ - min_) / (nums.size() - 1));
        for(int num : nums) {
            int idx = (num - min_) / gap;
            if(bucket[idx].empty()) {
                bucket[idx].emplace_back(num);
                bucket[idx].emplace_back(num);
            } else {
                bucket[idx][0] = min(bucket[idx][0], num);
                bucket[idx][1] = max(bucket[idx][1], num);
            }
        }
        int ret = 0;
        int last = bucket[0][0];
        for(int i = 0; i < nums.size(); i++) {
            if(bucket[i].empty())
                continue;
            for(int j = 0; j < 2; j++) {
                if(bucket[i][j] > last)
                    ret = max(ret, bucket[i][j] - last);
                last = bucket[i][j];
            }
        }
        return ret;
    }
};
//171. Excel Sheet Column Number
class Solution {
public:
    int titleToNumber(string s) {
        int ret = 0;
        int k = 1;
        for(int i = (int)s.length() - 1; i >= 0; i--) {
            ret += (s[i] - 'A' + 1) * k;
            k *= 26;
        }
        return ret;
    }
};
//173. Binary Search Tree Iterator
class BSTIterator {
private:
    stack<TreeNode*> st;
    void pushLeft(TreeNode* node) {
        while(node) {
            st.push(node);
            node = node->left;
        }
    }
    
public:
    BSTIterator(TreeNode *root) {
        pushLeft(root);
    }
    
    bool hasNext() {
        return !st.empty();
    }
    
    int next() {
        TreeNode* node = st.top();
        st.pop();
        int res = node->val;
        pushLeft(node->right);
        return res;
    }
};
//179. Largest Number
class Solution {
public:
    string largestNumber(vector<int>& nums) {
        vector<string> vec;
        char buff[33];
        for(int num : nums) {
            sprintf(buff, "%d", num);
            vec.emplace_back(buff);
        }
        sort(vec.begin(), vec.end(), myComparator);
        string ret;
        for(string str : vec) {
            ret += str;
        }
        int k = 0;
        while(k < ret.length() - 1 && ret[k] == '0')
            k++;
        return ret.substr(k);
    }
private:
    static bool myComparator(string s1,string s2) {
        return s1 + s2 > s2 + s1 ? true : false;
    }
};
//187. Repeated DNA Sequences
class Solution {
public:
    vector<string> findRepeatedDnaSequences(string s) {
        unordered_set<string> set_;
        unordered_set<string> set_res;
        vector<string> res;
        int len = s.length();
        for(int i = 1; i < len - 9; i++) {
            set_.insert(s.substr(i - 1, 10));
            string str = s.substr(i, 10);
            if(set_.find(str) != set_.end() && set_res.find(str) == set_res.end()) {
                set_res.insert(str);
                res.emplace_back(str);
            }
        }
        return res;
    }
};
class Solution {
public:
    vector<string> findRepeatedDnaSequences(string s) {
        vector<string> vec;
        if(s.length() < 10)
            return vec;
        map<char, int> dict;
        dict['A'] = 0;
        dict['C'] = 1;
        dict['G'] = 2;
        dict['T'] = 3;
        bitset<1 << 20> bits;
        bitset<1 << 20> flag;
        int len = (int)s.length();
        int mask = (1 << 20) - 1;
        int idx = 0;
        int i;
        for(i = 0; i < 10; i++) {
            idx = ((idx << 2) & mask) | dict[s[i]];
        }
        bits[idx] = 1;
        while(i < len) {
            idx = ((idx << 2) & mask) | dict[s[i]];
            if(bits[idx] && !flag[idx]) {
                flag[idx] = 1;
                vec.emplace_back(s.substr(i - 9, 10));
            }
            if(!bits[idx]) {
                bits[idx] = 1;
            }
            i++;
        }
        return vec;
    }
};
//190. Reverse Bits
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        uint32_t ret = 0;
        for (int i = 0; i < 32; i++) {
            if ((1 << i) & n)
                ret |= 1 << (32 - i - 1);
        }
        return ret;
    }
};
//174. Dungeon Game
class Solution {
public:
    int calculateMinimumHP(vector<vector<int>>& dungeon) {
        int m = (int)dungeon.size();
        int n = (int)dungeon[0].size();
        vector<vector<int>> dp(m, vector<int>(n));
        dp[m - 1][n - 1] = max(1, 1 -  dungeon[m - 1][n - 1]);
        for(int i = m - 2; i >= 0; i--)
            dp[i][n - 1] = max(1, dp[i + 1][n - 1] - dungeon[i][n - 1]);
        for(int j = n - 2; j >= 0; j--)
            dp[m - 1][j] = max(1, dp[m - 1][j + 1] - dungeon[m - 1][j]);
        for(int i = m - 2; i >= 0; i--) {
            for(int j = n - 2; j >= 0; j--) {
                dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j]);
            }
        }
        return dp[0][0];
    }
};
//189. Rotate Array
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        int n = (int)nums.size();
        k %= n;
        int m = (k != 0 && n % k == 0) ? k : 1;
        m = (k != 0 && n % (n - k) == 0) ? n - k : m;
        for(int i = 0; i < m; i++) {
            int tmp = nums[i];
            int idx = i;
            for(int j = 0; j < n / m - 1; j++) {
                nums[idx] = idx >= k ? nums[idx - k] : nums[idx + n - k];
                idx = idx >= k ? idx - k : idx + n - k;
            }
            nums[idx] = tmp;
        }
    }
};
//198. House Robber
class Solution {
public:
    int rob(vector<int>& nums) {
        int len = (int)nums.size();
        if(len == 0) return 0;
        if(len == 1) return nums[0];
        if(len == 2) return max(nums[0],  nums[1]);
        vector<int> dp(nums.size(), 0);
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for(int i = 2; i < nums.size(); i++) {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[len - 1];
    }
};
//199. Binary Tree Right Side View
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> res;
        if(!root)
            return res;
        stack<pair<TreeNode*, int>> st;
        st.emplace(root, 0);
        int depth = -1;
        while(!st.empty()) {
            auto it = st.top();
            st.pop();
            if(it.second > depth) {
                res.emplace_back(it.first->val);
                depth = it.second;
            }
            if(it.first->left)
                st.emplace(it.first->left, it.second + 1);
            if(it.first->right)
                st.emplace(it.first->right, it.second + 1);
        }
        return res;
    }
};
//200. Number of Islands
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
        if(grid.empty())
            return 0;
        int res = 0;
        int m = (int)grid.size();
        int n = (int)grid[0].size();
        int xx[] = {0, 0, -1, 1};
        int yy[] = {-1, 1, 0, 0};
        vector<vector<bool>> flag(m, vector<bool>(n, false));
        queue<pair<int,int>> q;
        for(int i = 0; i < m; i++) {
            for(int j = 0; j < n; j++) {
                if(grid[i][j] == '1' && !flag[i][j]) {
                    q.emplace(i, j);
                    flag[i][j] = true;
                    res++;
                    while(!q.empty()) {
                        auto it = q.front();
                        q.pop();
                        for(int k = 0; k < 4; k++) {
                            int ii = it.first + xx[k];
                            int jj = it.second + yy[k];
                            if(ii >= 0 && ii < m && jj >= 0 && jj < n && grid[ii][jj] == '1' && !flag[ii][jj]) {
                                flag[ii][jj] = true;
                                q.emplace(ii, jj);
                            }
                        }
                    }
                }
            }
        }
        return res;
    }
};
//203. Remove Linked List Elements
class Solution {
public:
    ListNode* removeElements(ListNode* head, int val) {
        ListNode* pHead = new ListNode(0);
        pHead->next = head;
        ListNode* p = pHead;
        while(p->next) {
            if(p->next->val == val) {
                ListNode* tmp = p->next;
                p->next = p->next->next;
                delete tmp;
            } else {
                p = p->next;
            }
        }
        ListNode* res = pHead->next;
        delete pHead;
        return res;
    }
};
//205. Isomorphic Strings
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        if(s.length() != t.length())
            return false;
        unordered_map<char, char> map_;
        unordered_set<char> set_;
        for(int i = 0; i < s.length(); i++) {
            if(map_.find(s[i]) == map_.end()) {
                if(set_.find(t[i]) != set_.end())
                    return false;
                map_[s[i]] = t[i];
                set_.insert(t[i]);
            } else {
                if(map_[s[i]] != t[i])
                    return false;
            }
        }
        return true;
    }
};
//206. Reverse Linked List
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(!head)
            return head;
        ListNode* pNext = head->next;
        ListNode* pre = NULL;
        head->next = pre;
        while(pNext) {
            pre = head;
            head = pNext;
            pNext = pNext->next;
            head->next = pre;
        }
        return head;
    }
};
//201. Bitwise AND of Numbers Range
class Solution {
public:
    int rangeBitwiseAnd(int m, int n) {
        int res = 0;
        for(int i = 31; i >= 0; i--) {
            if((m & (1 << i)) != (n & (1 << i)))
                break;
            res |= (m & (1 << i));
        }
        return res;
    }
};
//204. Count Primes
class Solution {
public:
    int countPrimes(int n) {
        if(n <= 2)
            return 0;
        vector<int> primes;
        primes.emplace_back(2);
        for(int i = 3; i < n; i += 2) {
            int sqrtI = sqrt(i);
            for(int j = 0; j < primes.size(); j++) {
                if(primes[j] > sqrtI) {
                    primes.emplace_back(i);
                    break;
                }
                if(i % primes[j] == 0)
                    break;
            }
        }
        return primes.size();
    }
};
class Solution {
public:
    int countPrimes(int n) {
        vector<bool> flags = vector<bool>(n, false);
        flags[0] = flags[1] = true;
        int count = 0;
        int sqrt_n = sqrt(n);
        for(int i = 2; i <= sqrt_n; i++) {
            if(!flags[i])
                for(int j = i * i; j < n; j += i)
                    flags[j] = true;
        }
        for(int i = 0; i < n; i++)
            if(!flags[i])
                count++;
        return count;
    }
};
//208. Implement Trie (Prefix Tree)
class Trie {
    struct TreeNode2 {
        bool isEnd;
        TreeNode2* childs[26] = {NULL};
        TreeNode2() : isEnd(false) { }
    };
    TreeNode2* root;
public:
    Trie() {
        root = new TreeNode2();
    }
    
    void insert(string word) {
        TreeNode2* node = root;
        for(char c : word) {
            if(node->childs[c - 'a'] == NULL)
                node->childs[c - 'a'] = new TreeNode2();
            node = node->childs[c - 'a'];
        }
        node->isEnd = true;
    }
    
    bool search(string word) {
        TreeNode2* node = root;
        for(char c : word) {
            if(node->childs[c - 'a'] == NULL)
                return false;
            node = node->childs[c - 'a'];
        }
        return node->isEnd;
    }
    
    bool startsWith(string prefix) {
        TreeNode2* node = root;
        for(char c : prefix) {
            if(node->childs[c - 'a'] == NULL)
                return false;
            node = node->childs[c - 'a'];
        }
        return true;
    }
};
//209. Minimum Size Subarray Sum
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int i = 0, j = 0;
        int n = (int)nums.size();
        int sum = 0;
        int res = 0;
        while(true) {
            while(j < n && sum < s)
                sum += nums[j++];
            if(sum < s)
                break;
            while(i < j && sum >= s)
                sum -= nums[i++];
            if(res == 0 || res > j - i + 1)
                res = j - i + 1;
        }
        return res;
    }
};
//211. Add and Search Word - Data structure design
class WordDictionary {
    struct TreeNode2 {
        bool isEnd;
        TreeNode2* childs[26] = {NULL};
        TreeNode2() : isEnd(false) { }
    };
    TreeNode2* root;
public:
    WordDictionary() {
        root = new TreeNode2();
    }
    
    void addWord(string word) {
        TreeNode2* node = root;
        for(char c : word) {
            if(node->childs[c - 'a'] == NULL)
                node->childs[c - 'a'] = new TreeNode2();
            node = node->childs[c - 'a'];
        }
        node->isEnd = true;
    }
    
    bool search(string word) {
        return search(root, word);
    }
private:
    bool search(TreeNode2* node, string word) {
        for(int i = 0; i < word.length(); i++) {
            if(word[i] == '.') {
                for(int j = 0; j < 26; j++)
                    if(node->childs[j] && search(node->childs[j], word.substr(i + 1)))
                        return true;
                return false;
            }
            if(node->childs[word[i] - 'a'] == NULL)
                return false;
            node = node->childs[word[i] - 'a'];
        }
        return node->isEnd;
    }
};
//188. Best Time to Buy and Sell Stock IV
class Solution {
public: //dp, O(n * k)) l[i][j]:day i must sell, g[i][j]: day i may not sell.
    int maxProfit(int k, vector<int>& prices) {
        if(prices.empty())
            return 0;
        if(k >= prices.size() / 2)
            return quickSolve(prices);
        int n = (int)prices.size();
        vector<int> l(k + 1, 0);
        vector<int> g(k + 1, 0);
        for(int i = 1; i < n; i++) {
            int diff = prices[i] - prices[i - 1];
            for(int j = k; j > 0; j--) {
                l[j] = max(g[j - 1] + max(diff, 0), l[j] + diff);
                g[j] = max(g[j], l[j]);
            }
        }
        return g[k];
    }
private:
    int quickSolve(vector<int>& prices) {
        int res = 0;
        for(int i = 1; i < prices.size(); i++) {
            if(prices[i] > prices[i - 1]) {
                res += prices[i] - prices[i - 1];
            }
        }
        return res;
    }
};
class Solution {
public: //dp[i][j] = max(dp[i][j - 1], max(dp[i - 1][t - 1] + prices[j] - prices[t])), tmp = max(dp[i - 1][t - 1] - prices[t])
    int maxProfit(int k, vector<int>& prices) {
        if(prices.empty())
            return 0;
        int n = (int)prices.size();
        if(k >= n / 2) {
            int res = 0;
            for(int i = 1; i < n; i++)
                if(prices[i] > prices[i - 1])
                    res += prices[i] - prices[i - 1];
            return res;
        }
        vector<vector<int>> dp(k + 1, vector<int>(n));
        for(int i = 1; i <= k; i++) {
            int tmp = -prices[0];
            for(int j = 1; j < n; j++) {
                dp[i][j] = max(dp[i][j - 1], tmp + prices[j]);
                tmp = max(tmp, dp[i - 1][j - 1] - prices[j]);
            }
        }
        return dp[k][n - 1];
    }
};
class Solution {
public: //O(n + k * log(n))
    int maxProfit(int k, vector<int>& prices) {
        int v, p = 0, res = 0;
        int n = (int)prices.size();
        priority_queue<int> profits;
        stack<pair<int, int>> vp_pairs;
        while(p < n) {
            for(v = p; v < n - 1 && prices[v + 1] <= prices[v]; v++);
            for(p = v + 1; p < n && prices[p] >= prices[p - 1]; p++);
            while(!vp_pairs.empty() && prices[vp_pairs.top().first] > prices[v]) {
                profits.emplace(prices[vp_pairs.top().second] - prices[vp_pairs.top().first]);
                vp_pairs.pop();
            }
            while(!vp_pairs.empty() && prices[vp_pairs.top().second] < prices[p - 1]) {
                profits.emplace(prices[vp_pairs.top().second] - prices[v]);
                v = vp_pairs.top().first;
                vp_pairs.pop();
            }
            vp_pairs.emplace(v, p - 1);
        }
        while(!vp_pairs.empty()) {
            profits.emplace(prices[vp_pairs.top().second] - prices[vp_pairs.top().first]);
            vp_pairs.pop();
        }
        for(int i = 0; i < k && !profits.empty(); i++) {
            res += profits.top();
            profits.pop();
        }
        return res;
    }
};
