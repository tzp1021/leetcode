//Fight!
//Single Number
class Solution {
public:
    int singleNumber(int A[], int n) {
        int ans=0;
        for(int i=0;i<n;i++)
            ans=ans^A[i];
        return ans;
    }
};

//Maximum Depth of Binary Tree
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode *root) {
        int max_depth=0;
        go(root,0,max_depth);
        return max_depth;
    }
    void go(TreeNode *node,int depth, int &max_depth) {
        if(node!=NULL) {
            depth++;
            if(depth>max_depth)
                max_depth=depth;
            go(node->left,depth,max_depth);
            go(node->right,depth,max_depth);
        }
    }
};

//Same Tree
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    bool isSameTree(TreeNode *node1, TreeNode *node2) {
         if(node1!=NULL && node2==NULL)
            return false;
        else if(node1==NULL && node2!=NULL)
            return false;
        else if(node1!=NULL && node2!=NULL) {
            if(node1->val!=node2->val)
                return false;
            else
                return isSameTree(node1->left,node2->left) && isSameTree(node1->right,node2->right);
        }
        return true;
    }
};

//Reverse Integer
class Solution {
public:
    int reverse(int x) {
       int ans=0;
        while(x) {
        	ans=ans*10+x%10;
            x/=10;
        }
        return ans;
    }
};

//Best Time to Buy and Sell Stock II
class Solution {
public:
    int maxProfit(vector<int> &prices) {
        int n=prices.size();
        if(n==0)
            return 0;
        int buy=prices[0];
        int ans=0;
        for(int i=1;i<n;i++) {
            if(prices[i]>buy)
                ans+=prices[i]-buy;
            buy=prices[i];
        }
        return ans;
    }
};

//Linked List Cycle 
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* one=head;
        ListNode* two=head;
        while(two!=NULL) {
            if(one->next!=NULL)
                one=one->next;
            if(two->next!=NULL && two->next->next!=NULL)
                two=two->next->next;
            else
                return false;
            if(one==two)
                return true;
        }
    }
};

//Unique Binary Search Trees
class Solution {
public:
    int numTrees(int n) {
        if(n==0)
            return 1;
        int ans=0;
        for(int i=1;i<=n;i++)
            ans+=numTrees(i-1)*numTrees(n-i);
        return ans;    
    }
};

//Populating Next Right Pointers in Each Node 
/**
 * Definition for binary tree with next pointer.
 * struct TreeLinkNode {
 *  int val;
 *  TreeLinkNode *left, *right, *next;
 *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
 * };
 */
class Solution {
public:
    void connect(TreeLinkNode *root) {
        if(root==NULL)
            return ;
        if(root->left!=NULL && root->right!=NULL)
            root->left->next=root->right;
        if(root->left!=NULL && root->next!=NULL)
            root->right->next=root->next->left;
        connect(root->left);
        connect(root->right);
    }
};

//Search Insert Position
class Solution {
public:
    int searchInsert(int A[], int n, int target) {
        int i=0,j=n-1;
        while(i<=j) {
            int mid=(i+j)/2;
            if(target<=A[mid])
                j=mid-1;
            else
                i=mid+1;
        }
        return i;
    }
};

//Remove Duplicates from Sorted List
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *deleteDuplicates(ListNode *head) {
        ListNode* ans=head;
        if(head==NULL)
            return ans;
        while(head->next!=NULL) {
            if(head->val==head->next->val) {
                ListNode* tmp=head->next;
                head->next=tmp->next;
                delete(tmp);
            }
            else
                head=head->next;
        }
        return ans;
    }
};

//Binary Tree Inorder Traversal 
class Solution {
public:
    vector<int> inorderTraversal(TreeNode *root) {
        vector<int> ans;
        if(root!=NULL)
            inorderTravel(root,ans);
        return ans;
    }
    void inorderTravel(TreeNode *node, vector<int> &v) {
        if(node->left!=NULL)
            inorderTravel(node->left,v);
        v.push_back(node->val);
        if(node->right!=NULL)
            inorderTravel(node->right,v);
    }
};

//Binary Tree Preorder Traversal
class Solution {
public:
    vector<int> preorderTraversal(TreeNode *root) {
        vector<int> ans;
        if(root!=NULL)
            preorderTravel(root,ans);
        return ans;
    }
    void preorderTravel(TreeNode *node, vector<int> &v) {
        v.push_back(node->val);
        if(node->left!=NULL)
            preorderTravel(node->left,v);
        if(node->right!=NULL)
            preorderTravel(node->right,v);
    }
};

//
