//Fight!

//Single Number
class Solution {
public:
    int singleNumber(int A[], int n) {
        int ans=0;
        for(int i=0;i<n;i++)
            ans=ans^A[i];
        return ans;
    }
};

//Maximum Depth of Binary Tree
class Solution {
public:
    int maxDepth(TreeNode *root) {
        int max_depth=0;
        go(root,0,max_depth);
        return max_depth;
    }
    void go(TreeNode *node,int depth, int &max_depth) {
        if(node!=NULL) {
            depth++;
            if(depth>max_depth)
                max_depth=depth;
            go(node->left,depth,max_depth);
            go(node->right,depth,max_depth);
        }
    }
};

//Same Tree
class Solution {
public:
    bool isSameTree(TreeNode *node1, TreeNode *node2) {
         if(node1!=NULL && node2==NULL)
            return false;
        else if(node1==NULL && node2!=NULL)
            return false;
        else if(node1!=NULL && node2!=NULL) {
            if(node1->val!=node2->val)
                return false;
            else
                return isSameTree(node1->left,node2->left) && isSameTree(node1->right,node2->right);
        }
        return true;
    }
};

//Reverse Integer
class Solution {
public:
    int reverse(int x) {
       int ans=0;
        while(x) {
        	ans=ans*10+x%10;
            x/=10;
        }
        return ans;
    }
};

//Best Time to Buy and Sell Stock II
class Solution {
public:
    int maxProfit(vector<int> &prices) {
        int n=prices.size();
        if(n==0)
            return 0;
        int buy=prices[0];
        int ans=0;
        for(int i=1;i<n;i++) {
            if(prices[i]>buy)
                ans+=prices[i]-buy;
            buy=prices[i];
        }
        return ans;
    }
};

//Linked List Cycle 
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* one=head;
        ListNode* two=head;
        while(two!=NULL) {
            if(one->next!=NULL)
                one=one->next;
            if(two->next!=NULL && two->next->next!=NULL)
                two=two->next->next;
            else
                return false;
            if(one==two)
                return true;
        }
    }
};

//Unique Binary Search Trees
class Solution {
public:
    int numTrees(int n) {
        if(n==0)
            return 1;
        int ans=0;
        for(int i=1;i<=n;i++)
            ans+=numTrees(i-1)*numTrees(n-i);
        return ans;    
    }
};

//Populating Next Right Pointers in Each Node 
/**
 * Definition for binary tree with next pointer.
 * struct TreeLinkNode {
 *  int val;
 *  TreeLinkNode *left, *right, *next;
 *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
 * };
 */
class Solution {
public:
    void connect(TreeLinkNode *root) {
        if(root==NULL)
            return ;
        if(root->left!=NULL && root->right!=NULL)
            root->left->next=root->right;
        if(root->right!=NULL && root->next!=NULL)
            root->right->next=root->next->left;
        connect(root->left);
        connect(root->right);
    }
};

//Search Insert Position
class Solution {
public:
    int searchInsert(int A[], int n, int target) {
        int i=0,j=n-1;
        while(i<=j) {
            int mid=(i+j)/2;
            if(target<=A[mid])
                j=mid-1;
            else
                i=mid+1;
        }
        return i;
    }
};

//Remove Duplicates from Sorted List
class Solution {
public:
    ListNode *deleteDuplicates(ListNode *head) {
        ListNode* ans=head;
        if(head==NULL)
            return ans;
        while(head->next!=NULL) {
            if(head->val==head->next->val) {
                ListNode* tmp=head->next;
                head->next=tmp->next;
                delete(tmp);
            }
            else
                head=head->next;
        }
        return ans;
    }
};

//Binary Tree Inorder Traversal 
class Solution {
public:
    vector<int> inorderTraversal(TreeNode *root) {
        vector<int> ans;
        if(root!=NULL)
            inorderTravel(root,ans);
        return ans;
    }
    void inorderTravel(TreeNode *node, vector<int> &v) {
        if(node->left!=NULL)
            inorderTravel(node->left,v);
        v.push_back(node->val);
        if(node->right!=NULL)
            inorderTravel(node->right,v);
    }
};

//Binary Tree Preorder Traversal
class Solution {
public:
    vector<int> preorderTraversal(TreeNode *root) {
        vector<int> ans;
        if(root!=NULL)
            preorderTravel(root,ans);
        return ans;
    }
    void preorderTravel(TreeNode *node, vector<int> &v) {
        v.push_back(node->val);
        if(node->left!=NULL)
            preorderTravel(node->left,v);
        if(node->right!=NULL)
            preorderTravel(node->right,v);
    }
};

//Climbing Stairs
class Solution {
public:
    int climbStairs(int n) {
        int a[2]={1,1},k;
        for(k=2;k<=n;k++) {
            a[k%2]=a[0]+a[1];
        }
        return a[(k+1)%2];
    }
};

//Remove Element
class Solution {
public:
    int removeElement(int A[], int n, int elem) {
        int i=0,j=n-1;
        while(i<=j) {
            while(i<n && A[i]!=elem)
                i++;
            while(j>=0 && A[j]==elem)
                j--;
            if(i>j)
                break;
            int t=A[i];
            A[i++]=A[j];
            A[j--]=t;
        }
        return i;
    }
};

//Remove Duplicates from Sorted Array
class Solution {
public:
    int removeDuplicates(int A[], int n) {
        if(n==0)
            return 0;
        int i=1;
        while(i<n && A[i-1]<A[i])
            i++;
        int j=i+1;
        while(j<n) {
            while(j<n && A[j]<=A[j-1])
                j++;
            if(j>=n)
                break;
            A[i++]=A[j++];
        }
        return i;
    }
};

//Maximum Subarray 
class Solution {
public:
    int maxSubArray(int A[], int n) {
        int ans=A[0],tmp=A[0];
        for(int i=1;i<n;i++) {
            tmp=(tmp<0) ? 0 : tmp;
            tmp+=A[i];
            ans=(tmp>ans) ? tmp : ans;
        }
        return ans;
    }
};

//Symmetric Tree 
class Solution {
public:
    bool isSymmetric(TreeNode *root) {
        if(root!=NULL)
            return isSame(root->left, root->right);
        return true;
    }
    bool isSame(TreeNode *node1, TreeNode *node2) {
        if(node1==NULL && node2==NULL)
            return true;
        if(node1!=NULL && node2==NULL)
            return false;
        if(node1==NULL && node2!=NULL)
            return false;
        if(node1->val!=node2->val)
            return false;
        return isSame(node1->left,node2->right) 
            && isSame(node1->right, node2->left);
    }
};

//Merge Two Sorted Lists
class Solution {
public:
    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {
        if(l2==NULL)
            return l1;
        if(l1==NULL)
            return l2;
        ListNode *ans=l1;
        if(l1->val > l2->val) {
            l1=l2;
            l2=ans;
            ans=l1;
        }
        while(l1->next!=NULL && l2!=NULL) {
            if(l1->next->val > l2->val) {
                ListNode *t1=l1->next;
                ListNode *t2=l2->next;
                l1->next=l2;
                l2->next=t1;
                l1=l2;
                l2=t2;
            }
            else
                l1=l1->next;
        }
        if(l2!=NULL)
            l1->next=l2;
        return ans;
    }
};

//Convert Sorted Array to Binary Search Tree
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode *sortedArrayToBST(vector<int> &num) {
        int n=num.size();
        if(n==0) 
            return NULL;
        TreeNode *root=new TreeNode(0);
        construct(num,0,n-1,root);
        return root;
    }
    void construct(vector<int> &num, int i, int j, TreeNode *node) {
        int mid=(i+j)/2;
        node->val=num[mid];
        if(i<mid) {
            TreeNode *l=new TreeNode(0);
            node->left=l;
            construct(num,i,mid-1,l);
        }
        if(j>mid) {
            TreeNode *r=new TreeNode(0);
            node->right=r;
            construct(num,mid+1,j,r);
        }
    }
};

//Next Permutation 
class Solution {
public:
    void nextPermutation(vector<int> &num) {
        const int n=num.size();
        int start=n-1;
        while(start>0 && num[start]<=num[start-1])
            start--;
        if(start>0) {
            int index=start;
            for(int i=start+1;i<n;i++)
                if(num[i]>num[start-1] && num[i]<num[index])
                    index=i;
            int tmp=num[index];
            num[index]=num[start-1];
            num[start-1]=tmp;
        }
        sort(num,start,n-1);
    }
    void sort(vector<int> &num,int s,int e) {
        if(s>=e)
            return;
        int i=s+1;
        int j=e;
        while(i<=j) {
            while(i<=e && num[i]<=num[s])
                i++;
            while(j>=s && num[j]>num[s])
                j--;
            if(i>=j)
                break;
            int t=num[i];
            num[i]=num[j];
            num[j]=t;
        }
        int t=num[s];
        num[s]=num[j];
        num[j]=t;
        if(j-1>s)
            sort(num,s,j-1);
        if(i<e)
            sort(num,i,e);
    }
};

//Merge Sorted Array
class Solution {
public:
    void merge(int A[], int m, int B[], int n) {
        int k=m+n-1;
        int i=m-1;
        int j=n-1;
        while(i>=0 && j>=0) {
            if(A[i]>=B[j]) 
                A[k--]=A[i--];
            else
                A[k--]=B[j--];
        }
        if(i<0) {
            while(j>=0)
                A[k--]=B[j--];
        }
    }
};

//Submission Details
class Solution {
public:
    ListNode *swapPairs(ListNode *head) {
        if(head==NULL || head->next==NULL)
            return head;
        ListNode *cur=head;
        head=head->next;
        cur->next=head->next;
        head->next=cur;
        ListNode *tmp;
        while(cur->next!=NULL && cur->next->next!=NULL) {
            tmp=cur->next;
            cur->next=tmp->next;
            tmp->next=cur->next->next;
            cur->next->next=tmp;
            cur=tmp;
        }
        return head;
    }
};

//Pascal's Triangle
class Solution {
public:
    vector<vector<int> > generate(int numRows) {
        vector<vector<int> > ans;
        for(int i=0;i<numRows;i++) {
            vector<int> cur;
            cur.push_back(1);
            for(int j=1;j<i;j++) 
                cur.push_back(ans[i-1][j-1]+ans[i-1][j]);
            if(i>0)
                cur.push_back(1);
            ans.push_back(cur);
        }
        return ans;
    }
};

//Best Time to Buy and Sell Stock 
class Solution {
public:
    int maxProfit(vector<int> &prices) {
        int n=prices.size();
        int ans=0,tmp=0;
        for(int i=1;i<n;i++) {
            tmp+=prices[i]-prices[i-1];
            if(tmp>ans)
                ans=tmp;
            if(tmp<0)
                tmp=0;
        }
        return ans;
    }
};

//Balanced Binary Tree
class Solution {
public:
    bool isBalanced(TreeNode *root) {
        if(root==NULL)
            return true;
        int c=height(root->left)-height(root->right);
        if(c>=-1 && c<=1 && isBalanced(root->left) && isBalanced(root->right))
            return true;
        return false;
    }
    int height(TreeNode *node) {
        if(node==NULL)
            return 0;
        return max(height(node->left),height(node->right))+1;
    }
};

//Gray Code
class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> ans;
        ans.push_back(0);
        int k=1;
        for(int i=0;i<n;i++) {
            for(int j=k-1;j>=0;j--) 
                ans.push_back(ans[j]+k);
            k=k<<1;
        }
        return ans;
    }
};

//Binary Tree Level Order Traversal II 
class Solution {
public:
    vector<vector<int> > levelOrderBottom(TreeNode *root) {
        vector<vector<int> > ans;
        if(root==NULL)
            return ans;
        queue<TreeNode*> level;
        int width=1;
        level.push(root);
        while(!level.empty()) {
            int num=0;
            vector<int> v;
            for(int i=0;i<width;i++) {
                TreeNode *node=level.front();
                level.pop();
                v.push_back(node->val);
                if(node->left!=NULL) {
                    level.push(node->left);
                    num++;
                }
                if(node->right!=NULL) {
                    level.push(node->right);
                    num++;
                }
            }
            width=num;
            ans.push_back(v);
        }
        int n=ans.size()-1;
        vector<vector<int> > fin_ans;
        while(n>=0) 
            fin_ans.push_back(ans[n--]);
        return fin_ans;
    }
};

//Permutations 
class Solution {
public:
    vector<vector<int> > permute(vector<int> &num) {
        vector<vector<int> > ans;
        int n=num.size();
        go(ans,num,n,0);
        return ans;
    }
    void go(vector<vector<int> > &ans,vector<int> &num, int n,int k) {
        if(k==n) {
            ans.push_back(num);
            return;
        }
        for(int i=k;i<n;i++) {
            swap(num,i,k);
            go(ans,num,n,k+1);
            swap(num,i,k);
        }
    }
    void swap(vector<int> &num, int i, int k) {
        int tmp=num[i];
        num[i]=num[k];
        num[k]=tmp;
    }
};

//Minimum Path Sum 
class Solution {
public:
    int minPathSum(vector<vector<int> > &grid) {
        int m=grid.size();
        int n=grid[0].size();
        vector<int> v;
        int tmp=0;
        for(int i=0;i<n;i++) {
            tmp+=grid[0][i];
            v.push_back(tmp);
        }
        for(int i=1;i<m;i++) {
            v[0]+=grid[i][0];
            for(int j=1;j<n;j++) 
                v[j]=min(v[j],v[j-1])+grid[i][j];
        }
        return v[n-1];
    }
};

//Single Number II
class Solution {
public:
    int singleNumber(int A[], int n) {
        int bits[32];
        memset(bits,0,sizeof(bits));
        for(int i=0;i<n;i++) {
            int num=A[i];
            int k=0;
            for(int j=0;j<32;j++) {
                bits[k++]+=num&1;
                num=num>>1;
            }
        }
        int ans=0;
        long long k=1;
        for(int i=0;i<31;i++) {
            bits[i]%=3;
            if(bits[i]!=0)
                ans+=k;
            k=k<<1;
        }
        if(bits[31]%3!=0)
            ans=(long long)ans-k;
        return ans;
    }
};

//Unique Paths 
class Solution {
public:
    int uniquePaths(int m, int n) {
        int a[105];
        for(int i=0;i<n;i++)
            a[i]=1;
        for(int i=1;i<m;i++)
            for(int j=1;j<n;j++)
                a[j]=a[j]+a[j-1];
        return a[n-1];
    }
};

//Rotate Image 
class Solution {
public:
    void rotate(vector<vector<int> > &matrix) {
        int n=matrix.size();
        for(int i=0;i<n/2;i++) {
            for(int j=i;j<n-i-1;j++) {
                int tmp=matrix[i][j];
                matrix[i][j]=matrix[n-1-j][i];
                matrix[n-1-j][i]=matrix[n-1-i][n-1-j];
                matrix[n-1-i][n-1-j]=matrix[j][n-1-i];
                matrix[j][n-1-i]=tmp;
            }
        }
    }
};

//Linked List Cycle II 
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *oneStep=head;
        ListNode *twoStep=head;
        while(twoStep!=NULL) {
            if(oneStep->next!=NULL)
                oneStep=oneStep->next;
            if(twoStep->next!=NULL && twoStep->next->next!=NULL)
                twoStep=twoStep->next->next;
            else
                return NULL;
            if(oneStep==twoStep) 
                break;
        }
        ListNode *start=head;
        while(1) {
            if(start==oneStep)
                return start;
            oneStep=oneStep->next;
            while(oneStep!=twoStep) {
                if(start==oneStep)
                    return start;
                oneStep=oneStep->next;
            }
            start=start->next;
        }
    }
};

//Search a 2D Matrix 
class Solution {
public:
    bool searchMatrix(vector<vector<int> > &matrix, int target) {
        int m=matrix.size();
        int n=matrix[0].size();
        int i=0;
        int j=m-1;
        while(i<=j) {
            int mid=(i+j)/2;
            if(matrix[mid][0]<=target)
                i=mid+1;
            else
                j=mid-1;
        }
        if(j<0)
            return false;
        int ii=0;
        int jj=n-1;
        while(ii<=jj) {
            int mid=(ii+jj)/2;
            if(matrix[j][mid]<=target)
                ii=mid+1;
            else
                jj=mid-1;
        }
        if(jj<0)
            return false;
        if(matrix[j][jj]==target)
            return true;
    }
};

//Plus One class Solution {
public:
    vector<int> plusOne(vector<int> &digits) {
        vector<int> ans;
        int n=digits.size()-1;
        while(n>=0 && digits[n]==9) {
            ans.insert(ans.begin(),0);
            n--;
        }
        if(n<0)
            ans.insert(ans.begin(),1);
        else {
            ans.insert(ans.begin(),digits[n--]+1);
            while(n>=0)
                ans.insert(ans.begin(),digits[n--]);
        }
        return ans;
    }
};

//Jump Game
class Solution {
public:
    bool canJump(int A[], int n) {
        int maxx=0;
        for(int i=0;i<n;i++) {
            if(i>maxx)
                break;
            maxx=(maxx>=A[i]+i) ? maxx : A[i]+i;
            if(maxx>=n-1)
                return true;
        }
        return false;
    }
};

//Binary Tree Postorder Traversal 
class Solution {
public:
    vector<int> postorderTraversal(TreeNode *root) {
        vector<int> ans;
        if(root!=NULL)
            postTravel(root,ans);
        return ans;
    }
    void postTravel(TreeNode *node, vector<int> &ans) {
        if(node->left!=NULL)
            postTravel(node->left,ans);
        if(node->right!=NULL)
            postTravel(node->right,ans);
        ans.push_back(node->val);
    }
};

//Binary Tree Level Order Traversal 
class Solution {
public:
    vector<vector<int> > levelOrder(TreeNode *root) {
        vector<vector<int> > ans;
        if(root==NULL)
            return ans;
        queue<TreeNode*> level;
        int width=1;
        level.push(root);
        while(!level.empty()) {
            int num=0;
            vector<int> v;
            for(int i=0;i<width;i++) {
                TreeNode *node=level.front();
                level.pop();
                v.push_back(node->val);
                if(node->left!=NULL) {
                    level.push(node->left);
                    num++;
                }
                if(node->right!=NULL) {
                    level.push(node->right);
                    num++;
                }
            }
            width=num;
            ans.push_back(v);
        }
        return ans;
    }
};

//Jump Game II
class Solution {
public:
    int jump(int A[], int n) {
        int ans=0;
        int num=0;
        int maxx=0;
        int i=0;
        while(maxx<n-1) {
            while(i<=num) {
                if(i+A[i]>maxx)
                    maxx=i+A[i];
                i++;
            }
            if(num==maxx)
                return -1;//could not reach
            num=maxx;
            ans++;
        }
        return ans;
    }
};

//Combinations 
class Solution {
public:
    vector<vector<int> > combine(int n, int k) {
        vector<vector<int> > ans;
        vector<int> cur;
        go(1,n,k,ans,cur);
        return ans;
    }
    void go(int s,int n,int k,vector<vector<int> > &ans, vector<int> &cur) {
        if(k==0) {
            ans.push_back(cur);
            return;
        }
        for(int i=s;i<=n-k+1;i++) {
            cur.push_back(i);
            go(i+1,n,k-1,ans,cur);
            cur.pop_back();
        }
    }
};

//Container With Most Water 
class Solution {
public:
    int maxArea(vector<int> &height) {
        int j=height.size()-1;
        int i=0;
        int ans=0;
        while(i<j) {
            int tmp=min(height[i],height[j])*(j-i);
            ans=(tmp>ans)? tmp : ans;
            if(height[i]>height[j]) {
                int k=j-1;
                while(k>i && height[k]<=height[j])
                    k--;
                j=k;
            }
            else {
                int k=i+1;
                while(k<j && height[k]<=height[i])
                    k++;
                i=k;
            }
        }
        return ans;
    }
};

//Sort Colors 
class Solution {
public:
    void sortColors(int A[], int n) {
        int i=0;
        while(i<n && A[i]==0)
            i++;
        int j=n-1;
        while(j>=0 && A[j]==2)
            j--;
        int k=i;
        while(k<=j) {
            if(k<j && A[k]==2) {
                A[k]=A[j];
                A[j--]=2;
                while(j>=0 && A[j]==2)
                    j--;
            }
            else if(i<k && A[k]==0) {
                A[k]=A[i];
                A[i++]=0;
                while(i<n && A[i]==0)
                    i++;
            }
            else
                k++;
        }
    }
};

//Path Sum
class Solution {
public:
    bool hasPathSum(TreeNode *root, int sum) {
        return go(root,0,sum);
    }
    bool go(const TreeNode *node, int s, const int &sum) {
        if(node==NULL)
            return false;
        s+=node->val;
        if(node->left==NULL && node->right==NULL) {
            if(s==sum)
                return true;
            else
                return false;
        }
        return go(node->left, s, sum) || go(node->right, s, sum);
    }
};

//Pascal's Triangle II 
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<int> ans;
        ans.push_back(1);
        for(int i=1;i<=rowIndex;i++) {
            ans.push_back(1);
            for(int j=i-1;j>0;j--)
                ans[j]+=ans[j-1];
        }
        return ans;
    }
};

//Search in Rotated Sorted Array
class Solution {
public:
    int search(int A[], int n, int target) {
        int i=0;
        int j=n-1;
        int mid;
        while(A[i]>A[j]) {
            mid=(i+j)/2;
            if(A[i]>=A[mid])
                j=mid;
            else
                i=mid;
        }
        mid=j;
        if(target>=A[0])
            return binarySearch(0,mid,A,target);
        else
            return binarySearch(mid+1,n-1,A,target);
    }
    int binarySearch(int i, int j, const int A[], const int target) {
        while(i<=j) {
            int mid=(i+j)/2;
            if(target==A[mid])
                return mid;
            if(target>A[mid])
                i=mid+1;
            else
                j=mid-1;
        }
        return -1;
    }
};

//Search in Rotated Sorted Array II
class Solution {
public:
    bool search(int A[], int n, int target) {
        int mid=0;
        while(mid<n-1 && A[mid]<=A[mid+1])
            mid++;
        if(target>=A[0])
            return binarySearch(0,mid,A,target);
        else
            return binarySearch(mid+1,n-1,A,target);
    }
    bool binarySearch(int i, int j, const int A[], const int target) {
        while(i<=j) {
            int mid=(i+j)/2;
            if(target==A[mid])
                return true;
            if(target>A[mid])
                i=mid+1;
            else
                j=mid-1;
        }
        return false;
    }
};

//Remove Nth Node From End of List
class Solution {
public:
    ListNode *removeNthFromEnd(ListNode *head, int n) {
        ListNode dummy(0);
        dummy.next=head;
        ListNode *front, *back;
        front=back=&dummy;
        for(int i=0;i<n;i++)
            back=back->next;
        while(back!=NULL && back->next!=NULL) {
            front=front->next;
            back=back->next;
        }
        ListNode *tmp=front->next;
        front->next=tmp->next;
        delete tmp;
        return dummy.next;
    }
};

//Populating Next Right Pointers in Each Node II 
class Solution {
public:
    void connect(TreeLinkNode *root) {
        TreeLinkNode *current=root;
        while(true) {
            TreeLinkNode *start=NULL;
            TreeLinkNode *left=NULL;
            while(current!=NULL) {
                if(current->left!=NULL) {
                    if(start==NULL) {
                        start=current->left;
                        left=start;
                    }
                    else {
                        left->next=current->left;
                        left=left->next;
                    }
                }
                if(current->right!=NULL) {
                    if(start==NULL) {
                        start=current->right;
                        left=start;
                    }
                    else {
                        left->next=current->right;
                        left=left->next;
                    }
                }
                current=current->next;
            }
            if(left!=NULL) {
                left->next=NULL;
                current=start;    
            }
            else
                break;
        }
    }
};

//Sum Root to Leaf Numbers
class Solution {
public:
    int sumNumbers(TreeNode *root) {
        return go(root,0);
    }
    int go(const TreeNode * const node, const int num) {
        if(node==NULL)
            return 0;
        int tmp=num*10+node->val;
        if(node->left==NULL && node->right==NULL)
            return tmp;
        return go(node->left,tmp)+go(node->right,tmp);
    }
};

//Minimum Depth of Binary Tree
class Solution {
public:
    int minDepth(TreeNode *root) {
        int ans=0;
        go(root,1,ans);
        return ans;
    }
    void go(const TreeNode * const node, const int n, int &ans) {
        if(node==NULL)
            return ;
        if(ans!=0 && n>=ans)
            return ;
        if(node->left==NULL && node->right==NULL) {
            ans=n;
            return ;
        }
        go(node->left,n+1,ans);
        go(node->right,n+1,ans);
        
    }
};

//Trapping Rain Water
class Solution {
public:
    int trap(int A[], int n) {
        stack<int> desc_que;
        int ans=0;
        desc_que.push(0);
        for(int i=1;i<n;i++) {
            int tmp=A[desc_que.top()];
            while(!desc_que.empty() && A[i]>tmp) {
                desc_que.pop();
                if(desc_que.empty())
                    break;
                if(A[desc_que.top()]<A[i]) 
                    ans+=(A[desc_que.top()]-tmp)*(i-desc_que.top()-1);
                else
                    ans+=(A[i]-tmp)*(i-desc_que.top()-1);
                tmp=A[desc_que.top()];
            }
            if(desc_que.empty() || A[i]<tmp) {
                desc_que.push(i);
            }
            else if(A[i]==tmp) {
                desc_que.pop();
                desc_que.push(i);
            }
        }
        return ans;
    }
};

//Length of Last Word
class Solution {
public:
    int lengthOfLastWord(const char *s) {
        int i=0;
        int ans=0;
        int tmp=0;
        while(s[i]!=NULL) {
            if(s[i++]!=' ')
                tmp++;
            else {
                ans=(tmp==0)? ans : tmp;
                tmp=0;
            }
        }
        ans=(tmp==0)? ans : tmp;
        return ans;
    }
};

//Valid Parentheses
class Solution {
public:
    bool isValid(string s) {
        stack<char> sta;
        int len=s.length();
        for(int i=0;i<len;i++) {
            if(s[i]=='(' || s[i]=='[' || s[i]=='{')
                sta.push(s[i]);
            else if(sta.empty() || 
                    ((s[i]==')' && sta.top()!='(')) ||
                    ((s[i]==']' && sta.top()!='[')) ||
                    ((s[i]=='}' && sta.top()!='{')) )
                    return false;
            else sta.pop();
        }
        if(sta.empty())
            return true;
        return false;
    }
};

//Path Sum II 
class Solution {
public:
    vector<vector<int> > pathSum(TreeNode *root, int tar) {
        vector<vector<int> > ans;
        vector<int> path;
        go(root,0,tar,path,ans);
        return ans;
    }
    void go(const TreeNode * const node, int sum, const int tar,
                vector<int> &path, vector<vector<int> > &ans) {
        if(node==NULL)
            return ;
        path.push_back(node->val);
        sum+=node->val;
        if(node->left==NULL && node->right==NULL && sum==tar) 
            ans.push_back(path);
        go(node->left, sum, tar, path, ans);
        go(node->right, sum, tar, path, ans);
        path.pop_back();
    }
};

//Valid Sudoku 
class Solution {
public:
    bool isValidSudoku(vector<vector<char> > &board) {
        bool a[10];
        for(int i=0;i<9;i++) {
            memset(a,false,sizeof(a));
            for(int j=0;j<9;j++) {
                if(board[i][j]=='.')
                    continue;
                if(a[board[i][j]-'1']==true) 
                    return false;
                a[board[i][j]-'1']=true;
            }
        }
        for(int j=0;j<9;j++) {
            memset(a,false,sizeof(a));
            for(int i=0;i<9;i++) {
                if(board[i][j]=='.')
                    continue;
                if(a[board[i][j]-'1']==true)
                    return false;
                a[board[i][j]-'1']=true;
            }
        }
        for(int i=0;i<9;i+=3) {
            for(int j=0;j<9;j+=3) {
                memset(a,false,sizeof(a));
                for(int ii=0;ii<3;ii++) {
                    for(int jj=0;jj<3;jj++) {
                        if(board[i+ii][j+jj]=='.')
                        continue;
                        if(a[board[i+ii][j+jj]-'1']==true)
                            return false;
                        a[board[i+ii][j+jj]-'1']=true;
                    }
                }
            }
        }
        return true;
    }
};

//Subsets
class Solution {
public:
    vector<vector<int> > subsets(vector<int> &S) {
        vector<vector<int> > ans;
        vector<int> tmp;
        int n=S.size();
        sort(S.begin(),S.end());
        for(int i=0;i<=n;i++) {
            go(S,i,0,n,ans,tmp);
        }
        return ans;
    } 
    void go(const vector<int> &S, const int left, const int k, 
                const int n, vector<vector<int> > &ans, vector<int> &tmp) {
        if(left==0) {
            ans.push_back(tmp);
            return ;
        }
        for(int i=k;i<n-left+1;i++) {
            tmp.push_back(S[i]);
            go(S,left-1,i+1,n,ans,tmp);
            tmp.pop_back();
        }
    }
};
class Solution {
public:
    vector<vector<int> > subsets(vector<int> &S) {
        sort(S.begin(), S.end());
        vector<vector<int> > v(1);
        for(int i = 0; i < S.size(); ++i) {
            int j = v.size();
            while(j-- > 0) {
                v.push_back(v[j]);
                v.back().push_back(S[i]);
            }
        }
        return v;
    }
};

//Search for a Range 
class Solution {
public:
    vector<int> searchRange(int A[], int n, int target) {
        vector<int> ans;
        int i=0;
        int j=n-1;
        while(i<=j) {
            int mid=(i+j)/2;
            if(A[mid]>=target) 
                j=mid-1;
            else
                i=mid+1;
        }
        if(A[i]==target)
            ans.push_back(i);
        else
            ans.push_back(-1);
        i=0;
        j=n-1;
        while(i<=j) {
            int mid=(i+j)/2;
            if(A[mid]>target) 
                j=mid-1;
            else
                i=mid+1;
        }
        if(A[j]==target)
            ans.push_back(j);
        else
            ans.push_back(-1);
        return ans;
        
    }
};

//N-Queens II 
class Solution {
public:
    int totalNQueens(int n) {
        int *row=new int[n];
        int ans=0;
        go(0,row,ans,n);
        delete []row;
        return ans;
    }
    void go(const int k, int *row, int &ans, const int n) {
        if(k==n) {
            ans++;
            return ;
        }
        for(int i=0;i<n;i++) {
            bool flag=true;
            for(int j=0;j<k;j++) {
                if(i==row[j] || (k-j)==abs(i-row[j])) {
                    flag=false;
                    break;
                }
            }
            if(flag==false)
                continue;
            row[k]=i;
            go(k+1,row,ans,n);
        }
    }
};

//Remove Duplicates from Sorted Array II 
class Solution {
public:
    int removeDuplicates(int A[], int n) {
        if(n<2)
            return n;
        int i=2;
        while(i<n && (A[i-1]!=A[i] || A[i-2]!=A[i]))
            i++;
        int j=i+1;
        while(j<n) {
            while(j<n && (A[j]==A[j-1] && A[j]==A[j-2]))
                j++;
            if(j>=n)
                break;
            swap(A[i],A[j]);
            if(A[i]!=A[i-1] || A[i]!=A[i-2])
                i++;
            j++;
        }
        return i;
    }
};

//Unique Paths II
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int> > &obstacleGrid) {
        int a[105];
        int m=obstacleGrid.size();
        int n=obstacleGrid[0].size();
        for(int i=0;i<n;i++)
            if(obstacleGrid[0][i]==1 || (i>0 && a[i-1]==0))
                a[i]=0;
            else
                a[i]=1;
        for(int i=1;i<m;i++) {
            if(obstacleGrid[i][0]==1)
                a[0]=0;
            for(int j=1;j<n;j++)
                if(obstacleGrid[i][j]==0)
                    a[j]=a[j]+a[j-1];
                else
                    a[j]=0;
        }
        return a[n-1];
    }
};

//Longest Common Prefix 
class Solution {
public:
    string longestCommonPrefix(vector<string> &strs) {
        string ans;
        int n=strs.size();
        if(n==0)
            return ans;
        int k=0;
        while(true) {
            if(k==strs[0].length())
                return ans;
            for(int i=1;i<n;i++) {
                if(k==strs[i].length() || strs[i][k]!=strs[0][k])
                    return ans;
            }
            ans+=strs[0][k];
            k++;
        }
        return ans;
    }
};

//Convert Sorted List to Binary Search Tree
class Solution {
public:
    TreeNode *sortedListToBST(ListNode *head) {
        int n=0;
        ListNode *tmp=head;
        while(tmp!=NULL) {
            tmp=tmp->next;
            n++;
        }
        return buildTree(head,0,n);
    }
    TreeNode * buildTree(ListNode *head, const int s, const int n) {
        if(s==n)
            return NULL;
        ListNode *tmp=head;
        for(int i=s;i<(s+n)/2;i++)
            tmp=tmp->next;
        TreeNode *cur=new TreeNode(tmp->val);
        cur->left=buildTree(head,s,(s+n)/2);
        cur->right=buildTree(tmp->next,(s+n)/2+1,n);
        return cur;
    }
};

//3Sum Closest 
class Solution {
public:
    int threeSumClosest(vector<int> &num, int target) {
        int n=num.size();
        sort(num.begin(),num.end());
        int ans=num[0]+num[1]+num[n-1];
        for(int k=0;k<n;k++) {
            int i=(k==0)?1:0;
            int j=(k==n-1)?n-2:n-1;
            int tmp=num[k]+num[i]+num[j];
            if(abs(ans-target)>abs(tmp-target))
                ans=tmp;
            while(i<j) {
                if(tmp<target)
                    i++;
                else if(tmp>target)
                    j--;
                else
                    return target;
                if(i==k) i++;
                if(j==k) j--;
                if(i==j) break;
                tmp=num[k]+num[i]+num[j];
                if(abs(ans-target)>abs(tmp-target))
                    ans=tmp;
            }
        }
        return ans;
    }
};

//Count and Say
class Solution {
public:
    string countAndSay(int n) {
        if(n<=0)
            return "";
        string ans="1";
        for(int i=1;i<n;i++) {
            int len=ans.length();
            int j=0;
            string tmp="";
            while(j<len) {
                int count=1;
                while(j<len-1 && ans[j+1]==ans[j]) {
                    count++;
                    j++;
                }
                tmp+=char('0'+count-0);
                tmp+=ans[j];
                j++;
            }
            ans=tmp;
        }
        return ans;
    }
};

//Pow(x, n) 
class Solution {
public:
    double pow(double x, int n) {
        if(n==0)
            return 1;
        if(n<0) {
            x=1.0/x;
            n=-n;
        }
        if(n&1) 
            return x*pow(x*x,n/2);
        else
            return pow(x*x,n/2);
    }
};

//Combination Sum
class Solution {
public:
    vector<vector<int> > combinationSum(vector<int> &candidates, int target) {
        sort(candidates.begin(),candidates.end());
        vector<vector<int> > ans;
        vector<int> cur;
        go(candidates,0,target,ans,cur);
        return ans;
    }
    void go(vector<int> &candidates, int ind, int target, vector<vector<int> > &ans, vector<int> &cur) {
        if(target==0) {
            ans.push_back(cur);
            return;
        }
        int n=candidates.size();
        while(ind<n && candidates[ind]<=target) {
            cur.push_back(candidates[ind]);
            go(candidates,ind,target-candidates[ind],ans,cur);
            cur.pop_back();
            ind++;
        }
    }
};

//Triangle
class Solution {
public:
    int minimumTotal(vector<vector<int> > &triangle) {
        int n=triangle.size();
        int *row=new int[n];
        for(int i=0;i<n;i++)
            row[i]=0;
        row[0]=triangle[0][0];
        for(int i=1;i<n;i++) {
            int tmp=row[0];
            row[0]+=triangle[i][0];
            for(int j=1;j<i;j++) {
                int t=min(row[j],tmp)+triangle[i][j];
                tmp=row[j];
                row[j]=t;
            }
            row[i]=tmp+triangle[i][i];
        }
        int ans=row[0];
        for(int i=1;i<n;i++)
            ans=min(ans,row[i]);
        delete []row;
        return ans;
    }
};

//Construct Binary Tree from Inorder and Postorder Traversal
class Solution {
public:
    TreeNode *buildTree(vector<int> &inorder, vector<int> &postorder) {
        int n=inorder.size();
        TreeNode *root=build(inorder,postorder,0,n-1,0,n-1);
        return root;
    }
    TreeNode *build(vector<int> &inorder, vector<int> &postorder, int is, int ie, int ps, int pe) {
        if(ps>pe)
            return NULL;
        TreeNode *head=new TreeNode(postorder[pe]);
        int i=is;
        while(i<=ie && inorder[i]!=postorder[pe])
            i++;
        head->left=build(inorder,postorder,is,i-1,ps,ps+i-is-1);
        head->right=build(inorder,postorder,i+1,ie,ps+i-is,pe-1);
		return head;
    }
};

//N-Queens
class Solution {
public:
    vector<vector<string> > solveNQueens(int n) {
        int *row=new int[n];
        vector<vector<string> > ans;
        go(0,row,ans,n);
        delete []row;
        return ans;
    }
    void go(const int k, int *row, vector<vector<string> > &ans, const int n) {
        if(k==n) {
            vector<string> cur;
            for(int i=0;i<n;i++) {
                string s="";
                for(int j=0;j<n;j++) {
                    if(j==row[i])
                        s+='Q';
                    else
                        s+='.';
                }
                cur.push_back(s);
            }
            ans.push_back(cur);
            return ;
        }
        for(int i=0;i<n;i++) {
            bool flag=true;
            for(int j=0;j<k;j++) {
                if(i==row[j] || (k-j)==abs(i-row[j])) {
                    flag=false;
                    break;
                }
            }
            if(flag==false)
                continue;
            row[k]=i;
            go(k+1,row,ans,n);
        }
    }
};

//Pow(x, n) 
class Solution {
public:
    double pow(double x, int n) {
        if(n==0)
            return 1;
        if(n<0) {
            x=1.0/x;
            n=-n;
        }
        if(n&1) 
            return x*pow(x*x,n/2);
        else
            return pow(x*x,n/2);
    }
};

//Combination Sum
class Solution {
public:
    vector<vector<int> > combinationSum(vector<int> &candidates, int target) {
        sort(candidates.begin(),candidates.end());
        vector<vector<int> > ans;
        vector<int> cur;
        go(candidates,0,target,ans,cur);
        return ans;
    }
    void go(vector<int> &candidates, int ind, int target, vector<vector<int> > &ans, vector<int> &cur) {
        if(target==0) {
            ans.push_back(cur);
            return;
        }
        int n=candidates.size();
        while(ind<n && candidates[ind]<=target) {
            cur.push_back(candidates[ind]);
            go(candidates,ind,target-candidates[ind],ans,cur);
            cur.pop_back();
            ind++;
        }
    }
};

//Add Binary
class Solution {
public:
    string addBinary(string a, string b) {
        string ans="";
        if(a.length()>b.length())
            swap(a,b);
        int len1=a.length();
        int len2=b.length();
        int flag=0;
        for(int i=0;i<len1;i++) {
            flag=a[len1-1-i]-'0'+b[len2-1-i]-'0'+flag;
            ans=char((flag&1)+'0')+ans;
            flag=flag>>1;
        }
        for(int i=len1;i<len2;i++) {
            flag=b[len2-1-i]-'0'+flag;
            ans=char((flag&1)+'0')+ans;
            flag=flag>>1;
        }
        if(flag)
            ans=char('0'+flag)+ans;
        return ans;
    }
};

//Validate Binary Search Tree
class Solution {
public:
    bool isValidBST(TreeNode *root) {
        return isValid(root,INT_MIN,INT_MAX);
    }
    bool isValid(TreeNode *root, int small, int big) {
        if(root==NULL)
            return true;
        if(root->val <= small || root->val >= big)
            return false;
        if(root->left!=NULL && root->left->val >= root->val)
            return false;
        if(root->right!=NULL && root->right->val <= root->val)
            return false;
        return isValid(root->left,small,root->val) && isValid(root->right,root->val,big);
    }
};

//Binary Tree Zigzag Level Order Traversal 
class Solution {
public:
    vector<vector<int> > zigzagLevelOrder(TreeNode *root) {
        vector<vector<int> > ans;
        if(root==NULL)
            return ans;
        vector<int> tmp;
        vector<TreeNode*> cur;
        vector<TreeNode*> next;
        bool reverse=false;
        cur.push_back(root);
        while(cur.size()!=0) {
            if(reverse==false)
                for(int i=0;i<cur.size();i++)
                    tmp.push_back(cur[i]->val);

            else 
                for(int i=cur.size()-1;i>=0;i--) 
                    tmp.push_back(cur[i]->val);
            for(int i=0;i<cur.size();i++) {
                if(cur[i]->left!=NULL)
                    next.push_back(cur[i]->left);
                if(cur[i]->right!=NULL)
                    next.push_back(cur[i]->right);
            }
            reverse=!reverse;
            ans.push_back(tmp);
            tmp.clear();
            cur=next;
            next.clear();
        }
        return ans;
    }
};

//Edit Distance
class Solution {
public:
    int minDistance(string word1, string word2) {
        int n = word1.length();
        int m = word2.length();
        int **matrix = new int*[n+1];
        for(int i = 0; i <= n; i++)
            matrix[i] = new int[m+1];
        for(int i = 0; i <= n; i++)
            matrix[i][0] = i;
        for(int j = 0; j <= m; j++)
            matrix[0][j] = j;
        
        for(int i = 1; i <=n; i++) {
            for(int j = 1; j <= m; j++) {
                int del = matrix[i-1][j] + 1;
                int ins = matrix[i][j-1] + 1;
                int rep = matrix[i-1][j-1];
                if(word1[i-1] != word2[j-1])
                    rep++;
                matrix[i][j] = min(del, ins);
                matrix[i][j] = min(matrix[i][j], rep);
            }   
        }
        int ans = matrix[n][m];
        for(int i = 0; i <= n; i++)
            delete[] matrix[i];
        delete[] matrix;
        return ans;
    }
};

//Gas Station 
class Solution {
public:
    int canCompleteCircuit(vector<int> &gas, vector<int> &cost) {
        int n = gas.size();
        int *num = new int[n];
        for(int i = 0; i < n; i++)
            num[i] = gas[i] - cost[i];
        int sum = 0;
        for(int i = 0; i < n; i++)
            sum += num[i];
        if(sum < 0)
            return -1;
        sum = 0;
        int ans = 0;
        for(int i = 0; i < n; i++) {
            sum += num[i];
            if(sum < 0) {
                sum = 0;
                ans = i + 1;
            }
        }
        delete[] num;
        return ans;
    }
};

//Roman to Integer 
class Solution {
public:
    int romanToInt(string s) {
        int n = s.length();
        if(n < 1) return 0;
        map<char, int> m;
        m['I'] = 1;
        m['V'] = 5;
        m['X'] = 10;
        m['L'] = 50;
        m['C'] = 100;
        m['D'] = 500;
        m['M'] = 1000;
        int i = n - 1;
        int ans = m[s[i--]];
        while(i >= 0) {
            if(m[s[i + 1]] > m[s[i]])
                ans -= m[s[i--]];
            else
                ans += m[s[i--]];
        }
        return ans;
    }
};

//Integer to Roman 
class Solution {
public:
    string intToRoman(int num) {
        string hundreds[10] = {"", "C", "CC", "CCC", "CD", "D", "DC", "DCC", "DCCC", "CM"};
        string tens[10] = {"", "X", "XX", "XXX", "XL", "L", "LX", "LXX", "LXXX", "XC"};
        string ones[10] = {"", "I", "II", "III", "IV", "V", "VI", "VII", "VIII", "IX"};
        string ans = "";
        while(num >= 1000) {
            num -= 1000;
            ans += "M";
        }
        ans += hundreds[num/100];
        num %= 100;
        ans += tens[num/10];
        num %= 10;
        ans += ones[num];
        return ans;
    }
};

//Generate Parentheses 
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        vector<string> ans;
        string cur = "";
        go(ans, cur, n, n);
        return ans;
    }
    void go(vector<string> &ans, string cur, int nl, int nr) {
        if(nl < nr) {
            if(nl != 0) {
                go(ans, cur + "(", nl-1, nr);
            }
            go(ans, cur + ")", nl, nr - 1);
        }
        else {
            if(nl == 0) {
                ans.push_back(cur);
                return;
            }
            go(ans, cur + "(", nl-1, nr);
        }
    }
};

//Flatten Binary Tree to Linked List 
class Solution {
public:
    void flatten(TreeNode *root) {
        while ( root ) {
            if ( root->left ) {
                TreeNode *ptr = root->left;
                while ( ptr->right ) ptr = ptr->right;
                ptr->right = root->right;
                root->right = root->left;
                root->left = NULL;
            }
            root = root->right;
        }
    }
};

//Longest Consecutive Sequence 
class Solution {
public:
    int longestConsecutive(vector<int> &num) {
        unordered_set<int> used, container;
        int ans = 0;
        for(int i = 0; i < num.size(); i++)
            container.insert(num[i]);
        for(unordered_set<int>::iterator it = container.begin(); it != container.end(); it++) {
            if(used.count(*it) == 0) {
                used.insert(*it);
                int count = 1;
                int l = *it - 1;
                int r = *it + 1;
                while(container.count(l) != 0) {
                    used.insert(l);
                    count++;
                    l--;
                }
                while(container.count(r) != 0) {
                    used.insert(r);
                    count++;
                    r++;
                }
                ans = max(ans, count);
            }
        }
        return ans;
    }
};

//Unique Binary Search Trees II 
class Solution {
public:
    vector<TreeNode *> generateTrees(int n) {
        return createTree(1, n);
    }
    vector<TreeNode *> createTree(int l, int r) {
        vector<TreeNode *> ans;
        if(l > r) {
            ans.push_back(NULL);
            return ans;
        }
        for(int k = l; k <= r; k++) {
            vector<TreeNode *> left = createTree(l, k - 1);
            vector<TreeNode *> right = createTree(k + 1, r);
            for(int i = 0; i < left.size(); i++) {
                for(int j = 0; j < right.size(); j++) {
                    TreeNode * root = new TreeNode(k);
                    root->left = left[i];
                    root->right = right[j];
                    ans.push_back(root);
                }
            }
        }
        return ans;
    }
    
};

//Subsets II 
class Solution {
public:
    vector<vector<int> > subsetsWithDup(vector<int> &S) {
        vector<vector<int> > ans(1);
        sort(S.begin(), S.end());
        int oldval = S[0];
        int oldj = 0;
        for(int i = 0; i < S.size(); i++) {
            int temp = oldj;
            if(S[i] != oldval) {
                oldval = S[i];
                temp = 0;
            }
            int j = ans.size();
            oldj = j;
            while(j-- > temp) {
                ans.push_back(ans[j]);
                ans.back().push_back(S[i]);
            }
        }
        return ans;
    }
};

//Partition List 
class Solution {
public:
    ListNode *partition(ListNode *head, int x) {
        ListNode *p = head;
        ListNode *pSmall = new ListNode(0);
        ListNode *small = pSmall;
        ListNode *pBig = new ListNode(0);
        ListNode *big = pBig;
        while(p != NULL) {
            if(p->val < x) {
                small->next = p;
                small = p;
            }
            else {
                big->next = p;
                big = p;
            }
            p = p->next;
        }
        small->next = pBig->next;
        big->next = NULL;
        ListNode *ans = pSmall->next;
        delete[] pSmall;
        delete[] pBig;
        return ans;
    }
};

//Construct Binary Tree from Preorder and Inorder Traversal
class Solution {
public:
    TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {
        return build(preorder, inorder, 0, preorder.size(), 0, inorder.size());
    }
    TreeNode *build(vector<int> &preorder, vector<int> &inorder, int s1, int e1, int s2, int e2) {
        if(s1 >= e1) 
            return NULL;
        TreeNode *root = new TreeNode(preorder[s1]);
        int root_index = s2;
        while(inorder[root_index] != preorder[s1])
            root_index++;
        int len_left = root_index - s2;
        root->left = build(preorder, inorder, s1+1, s1 + len_left + 1, s2, root_index);
        root->right = build(preorder, inorder, s1 + len_left + 1, e1, root_index + 1, e2);
        return root;
    }
};

//Letter Combinations of a Phone Number
class Solution {
public:
    vector<string> letterCombinations(string digits) {
        vector<string> ans;
		string letter[] = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
		go(ans, letter, digits, 0, "");
        return ans;
    }
    void go(vector<string> &ans, string *letter, const string &digits, int k, string cur) {
		if(k >= digits.length()) {
            ans.push_back(cur);
            return;
        }
        int num = digits[k] - '0';
        for(int i = 0; i < letter[num].length(); i++) {
            string tmp = cur + letter[num][i];
            go(ans, letter, digits, k + 1, tmp);
        }
    }
};

//Reverse Linked List II 
class Solution {
public:
    ListNode *reverseBetween(ListNode *head, int m, int n) {
		if(m >= n)
			return head;
        ListNode *addition = new ListNode(0);
        addition->next = head;
        ListNode *pre_m = addition;
        for(int i = 0; i < m - 1; i++)
            pre_m = pre_m->next;
        ListNode *node_m = pre_m->next;
        ListNode *pre_p = node_m;
        ListNode *p = pre_p->next;
		ListNode *post_p = p->next;
        for(int i = m; i < n; i++) {
            p->next = pre_p;
            pre_p = p;
            p = post_p;
			if(post_p != NULL)
	            post_p = post_p->next;
        }
        pre_m->next = pre_p;
        node_m->next = p;
        p = addition->next;
        delete[] addition;
		if(m > 1)
	        return head;
		else 
			return p;
    }
};

//Insertion Sort List 
class Solution {
public:
    ListNode *insertionSortList(ListNode *head) {
        if(head == NULL)
            return NULL;
        ListNode *newHead = new ListNode(0);
        newHead->next = head;
		for(ListNode *p = head->next, *pre_p = head; p != NULL; pre_p = p, p = p->next) {
			for(ListNode *cur = newHead; cur->next != p; cur = cur->next) {
				if(cur->next->val > p->val) {
					pre_p->next = p->next;
					p->next = cur->next;
					cur->next = p;
					p = pre_p;
					break;
				}
			}
		}
        ListNode *ans = newHead->next;
        delete[] newHead;
        return ans;
    }
};

//Permutations II 
class Solution {
public:
    vector<vector<int> > permuteUnique(vector<int> &num) {
        vector<vector<int> > ans;
        go(ans,num,0);
        return ans;
    }
    void go(vector<vector<int> > &ans,vector<int> &num, int k) {
        if(k==num.size()) {
            ans.push_back(num);
            return;
        }
        for(int i=k;i<num.size();i++) {
            if(!is_first(num, k, i))
                continue;
            swap(num[i],num[k]);
            go(ans,num,k+1);
            swap(num[i],num[k]);
        }
    }
    bool is_first(vector<int> &num, int s, int e) {
        for(int i = s; i < e; i++) {
            if(num[i] == num[e])
                return false;
        }
        return true;
    }
};

//Palindrome Partitioning
class Solution {
public:
    vector<vector<string>> partition(string s) {
        vector<vector<string> > ans;
        vector<string> cur;
        dfs(ans, cur, s);
        return ans;
    }
    void dfs(vector<vector<string> > &ans, vector<string> &cur, string s) {
        if(s.length() < 1) {
            ans.push_back(cur);
            return;
        }
        for(int i = 0; i < s.length(); i++) {
            int start = 0;
            int end = i;
            while(start < end) {
                if(s[start] == s[end]) {
                    start++;
                    end--;
                }
                else
                    break;
            }
            if(start >= end) {
                cur.push_back(s.substr(0, i+1));
                dfs(ans, cur, s.substr(i+1));
                cur.pop_back();
            }
        }
    }
};

//Remove Duplicates from Sorted List II 
class Solution {
public:
    ListNode *deleteDuplicates(ListNode *head) {
        ListNode *newHead = new ListNode(0);
        newHead->next = head;
        ListNode *p = newHead;
        while(p->next != NULL && p->next->next != NULL) {
            if(p->next->val != p->next->next->val)
                p = p->next;
            else {
                int num = p->next->val;
                ListNode *pp = p->next;
                while(pp != NULL && pp->val == num) {
                    p->next = pp->next;
                    delete[] pp;
                    pp = p->next;
                }
            }
        }
        p = newHead->next;
        delete[] newHead;
        return p;
    }
};

//Reverse Nodes in k-Group 
class Solution {
public:
    ListNode *reverseKGroup(ListNode *head, int k) {
        if(k < 2)
            return head;
        ListNode *newHead = new ListNode(0);
        newHead->next = head;
        ListNode *p = newHead;
        ListNode *tail = p;
        while(tail != NULL) {
            for(int i = 0; i < k; i++)
                if(tail!=NULL)
                    tail = tail->next;
                else
                    break;
            if(tail != NULL) {
                ListNode *front = p->next;
                ListNode *pre = front;
                ListNode *in = pre->next;
                ListNode *post = in->next;
                for(int i = 0; i < k - 1; i++) {
                    in->next = pre;
                    pre = in;
                    in = post;
                    if(post != NULL)
                        post = post->next;
                }
                p->next = tail;
                front->next = in;
                p = front;
                tail = p;
            }
        }
        p = newHead->next;
        delete[] newHead;
        return p;
    }
};

//Distinct Subsequences 
class Solution {
public:
    int numDistinct(string S, string T) {
        int n1 = S.length();
        int n2 = T.length();
        vector<vector<int>> dp(n2+1, vector<int>(n1+1, 0));
        for(int i = 0; i <= n1; i++)
            dp[0][i] = 1;
        for(int j = 1; j <= n2; j++) {
            for(int i =1; i <= n1; i++) {
                dp[j][i] = dp[j][i-1];
                if(S[i-1] == T[j-1])
                    dp[j][i] += dp[j-1][i-1];
            }
        }
        return dp[n2][n1];
    }
};
class Solution {
public:
    int numDistinct(string S, string T) {
        int n1 = S.length();
        int n2 = T.length();
        vector<int> dp(n2+1, 0);
        dp[0] = 1;
        for(int i =1; i <= n1; i++) {
            for(int j = n2; j > 0; j--) {
                if(S[i-1] == T[j-1])
                    dp[j] += dp[j-1];
            }
        }
        return dp[n2];
    }
};

//Combination Sum II
class Solution {
public:
    vector<vector<int> > combinationSum2(vector<int> &num, int target) {
        sort(num.begin(),num.end());
        vector<vector<int> > ans;
        vector<int> cur;
        vector<bool> flags(num.size(), false);
        go(num,0,target,flags,ans,cur);
        return ans;
    }
    void go(vector<int> &num, int ind, int target, vector<bool> &flags, vector<vector<int> > &ans, vector<int> &cur) {
        if(target==0) {
            ans.push_back(cur);
            return;
        }
        int n=num.size();
        if(ind<n && num[ind]<=target) {
            if(!(ind > 0 && num[ind] == num[ind-1] && flags[ind-1]==false)) {
                flags[ind] = true;
                cur.push_back(num[ind]);
                go(num,ind+1,target-num[ind],flags,ans,cur);
                cur.pop_back();
                flags[ind] = false;
            }
            go(num, ind+1, target, flags, ans, cur);
        }
    }
};

//ZigZag Conversion 
class Solution {
public:
    string convert(string s, int nRows) {
        if(nRows <= 1)
            return s;
        string ans = "";
        for(int i = 0; i < nRows; i++) {
            int j = i;
            if(i == 0 || i == nRows-1) {
                while(j < s.size()) {
                    ans += s[j];
                    j += 2 * nRows - 2;
                }
            }
            else {
                while(j < s.size()) {
                    ans += s[j];
                    if(j + 2 * nRows - 2 - 2 * i < s.size())
                        ans += s[j + 2 * nRows - 2 - 2 * i];
                    j += 2 * nRows - 2;
                }
            }
        }
        return ans;
    }
};

//3Sum 
class Solution {
public:
    vector<vector<int> > threeSum(vector<int> &num) {
        sort(num.begin(), num.end());
        vector<vector<int> > ans;
        int n = num.size();
        for(int k = 0; k < n - 2; k++) {
            if(k > 0 && num[k] == num[k-1])
                continue;
            int i = k + 1;
            int j = n - 1;
            while(i < j) {
                while(i > k + 1 && num[i] == num[i-1])
                    i++;
                while(i < j && num[i] + num[j] >= -num[k])
                    j--;
                if(j < n - 1 && num[i] + num[j+1] == -num[k]) {
                    vector<int> tmp;
                    tmp.push_back(num[k]);
                    tmp.push_back(num[i]);
                    tmp.push_back(num[j+1]);
                    ans.push_back(tmp);
                }
                i++;
            }
        }
        return ans;
    }
};

//Anagrams
class Solution {
public:
    vector<string> anagrams(vector<string> &strs) {
        map<string, int> m;
        vector<string> ans;
        for(int i = 0; i < strs.size(); i++) {
            string tmp = strs[i];
            sort(tmp.begin(), tmp.end());
            if(m.find(tmp) == m.end()) {
                m[tmp] = i;
            }
            else {
                if(m[tmp] >= 0) {
                    ans.push_back(strs[m[tmp]]);
                    m[tmp] = -1;
                }
                ans.push_back(strs[i]);
            }
        }
        return ans;
    }
};

//Copy List with Random Pointer
class Solution {
public:
    RandomListNode *copyRandomList(RandomListNode *head) {
        map<RandomListNode *, int> m;
        vector<RandomListNode *> v;
        RandomListNode *p = head;
        int k = 0;
        while(p != NULL) {
            if(m.find(p) != m.end()) {
                break;
            }
            RandomListNode *node = new RandomListNode(p->label);
            v.push_back(node);
            m[p] = k;
            k++;
            p = p->next;
        }
        m[NULL] = k;
        v.push_back(NULL);
        p = head;
        for(int i = 0; i < v.size() - 1; i++) {
            v[i]->next = v[i+1];
            v[i]->random = v[m[p->random]];
            p = p->next;
        }
        return v[0];
    }
};

//Recover Binary Search Tree
class Solution {
public:
    void recoverTree(TreeNode *root) {
        TreeNode *big, *small, *front;
        big = small = front = NULL;
        go(root, front, big, small);
        swap(big->val, small->val);
    }
    void go(TreeNode *cur, TreeNode *&front, TreeNode *&big, TreeNode *&small) {
        if(cur->left != NULL)
            go(cur->left, front, big, small);
        if(front != NULL && front->val > cur->val) {
            if(big == NULL)
                big = front;
            small = cur;
        }
        front = cur;
        if(cur->right != NULL)
            go(cur->right, front, big, small);
    }
};

//Add Two Numbers
class Solution {
public:
    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {
        ListNode *p1 = l1;
        ListNode *p2 = l2;
        ListNode *ans = new ListNode(0);
        ListNode *p = ans;
        ListNode *pre_p = NULL;
        bool flag = false;
        while(p1 != NULL || p2 != NULL) {
            if(p1) {
                p->val += p1->val;
                p1 = p1->next;
            }
            if(p2) {
                p->val += p2->val;
                p2 = p2->next;
            }
            if(flag)
                p->val++;
            flag = false;
            if(p->val >= 10) {
                p->val -= 10;
                flag = true;
            }
            if(pre_p)
                pre_p = pre_p->next;
            else
                pre_p = p;
            ListNode *nextt = new ListNode(0);
            p->next = nextt;
            p = p->next;
        }
        if(flag)
            p->val = 1;
        else {
            delete[] p;
            pre_p->next = NULL;
        }
        return ans;
    }
};

//Valid Palindrome 
class Solution {
public:
    bool is_num(char c) {
        if(c >= '0' && c <= '9')
            return true;
        return false;
    }
    bool is_alpha_num(char c) {
        if(c >= 'a' && c <= 'z')
            return true;
        return is_big_alpha(c) || is_num(c);
    }
    bool is_big_alpha(char c) {
        if(c >= 'A' && c <= 'Z')
            return true;
        return false;
    }
    char lowercase(char c) {
        if(is_big_alpha(c))
            return c-'A'+'a';
        return c;
    }
    bool isPalindrome(string s) {
        int i = 0;
        int j = s.size() - 1;
        while(i < j) {
            while(i < s.size() && !is_alpha_num(s[i]))
                i++;
            while(j >= 0 && !is_alpha_num(s[j]))
                j--;
            if(i < j && lowercase(s[i]) != lowercase(s[j]))
                return false;
            i++;
            j--;
        }
        return true;
    }
};

//Clone Graph 
class Solution {
public:
    UndirectedGraphNode *cloneGraph(UndirectedGraphNode *node) {
        map<UndirectedGraphNode *, int> m;
        vector<UndirectedGraphNode *> v;
        go(node, m, v, 0);
        v.push_back(NULL);
        return v[0];
    }
    void go(UndirectedGraphNode *node, map<UndirectedGraphNode *, int> &m, vector<UndirectedGraphNode *> &v, int k) {
        if(node == NULL)
            return;
        m[node] = k;
        UndirectedGraphNode *c_node = new UndirectedGraphNode(node->label);
        v.push_back(c_node);
        for(int i = 0; i < node->neighbors.size(); i++) {
            if(m.find(node->neighbors[i]) != m.end()) { 
                c_node->neighbors.push_back(v[m[node->neighbors[i]]]);
                continue;
            }
            go(node->neighbors[i], m, v, k+1);
            c_node->neighbors.push_back(v[m[node->neighbors[i]]]);
        }
    }
};

//Binary Tree Maximum Path Sum 
class Solution {
public:
    int maxPathSum(TreeNode *root) {
        if(root == NULL)
            return 0;
        vector<int> v = go(root);
        return v[0];
    }
    vector<int> go(TreeNode *root) {
        vector<int> v(2, 0);
        v[0] = INT_MIN;
        if(root == NULL)
            return v;
        vector<int> v1 = go(root->left);
        v1[1] = max(v1[1], 0);
        vector<int> v2 = go(root->right);
        v2[1] = max(v2[1], 0);
        v[0] = max(v1[0], v2[0]);
        v[0] = max(v[0], v1[1]+v2[1]+root->val);
        v[1] = max(v1[1], v2[1]) + root->val;
        return v;
    }
};

//First Missing Positive
class Solution {
public:
    int firstMissingPositive(int A[], int n) {
        for(int i = 0; i < n; i++) {
            if(A[i] <= 0 || A[i] > n)
                continue;
            while(A[i] > 0 && A[i] <= n && A[i] != A[A[i]-1]) {
                swap(A[i], A[A[i]-1]);
            }
        }
        for(int i = 0; i < n; i++) {
            if(A[i] != i + 1)
                return i + 1;
        }
        return n + 1;
    }
};

//Scramble String 
class Solution {
public:
    bool is_same(string s1, string s2) {
        sort(s1.begin(), s1.end());
        sort(s2.begin(), s2.end());
        return s1 == s2;
    }
    bool isScramble(string s1, string s2) {
        if(s1 == s2)
            return true;
        if(is_same(s1, s2) == false)
            return false;
        for(int i = 1; i <= s1.size() - 1; i++) {
            if(isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i) , s2.substr(i)))
                return true;
            if(isScramble(s1.substr(0, i), s2.substr(s2.size() - i)) 
                && isScramble(s1.substr(i) , s2.substr(0, s2.size() - i)))
                return true;
        }
        return false;
    }
};

//Longest Substring Without Repeating Characters
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        set<char> ss;
        int ans = 0;
        int i = 0;
        int j = 0;
        while(j < s.size()) {
            while(j < s.size() && ss.find(s[j]) == ss.end()) {
                ss.insert(s[j]);
                j++;
            }
            ans = max(ans, j - i);
            ss.erase(s[i]);
            i++;
        }
        return ans;
    }
};

//Sqrt(x) 
class Solution {
public:
    int sqrt(int x) {
        int i = 0;
        int j = x;
        while(i <= j) {
            int mid = (i + j) / 2;
            if((long long)mid * mid > x)
                j = mid - 1;
            else 
                i = mid + 1;
        }
        return j;
    }
};

//Best Time to Buy and Sell Stock III 
class Solution {
public:
    int maxProfit(vector<int> &prices) {
        int n = prices.size();
        vector<int> pre(n, 0);
        int tmp = 0;
        for(int i = 1; i < n; i++) {
            tmp += prices[i] - prices[i-1];
            pre[i] = max(pre[i-1], tmp);
            tmp = max(tmp, 0);
        }
        vector<int> post(n, 0);
        tmp = 0;
        for(int i = n - 2; i >= 0; i--) {
            tmp += prices[i+1] - prices[i];
            post[i] = max(post[i+1], tmp);
            tmp = max(tmp, 0);
        }
        int ans = 0;
        for(int i = 0; i < n; i++) {
            ans = max(ans, pre[i] + post[i]);
        }
        return ans;
    }
};

//Permutation Sequence 
class Solution {
public:
    string getPermutation(int n, int k) {
        k--;
        int jiecheng = 1;
        for(int i = 2; i < n; i++)
            jiecheng *= i;
        vector<char> num;
        for(int i = 0; i < n; i++)
            num.push_back(i + '1');
        string ans = "";
        for(int i = n - 1; i > 0; i--) {
            int index = k / jiecheng;
            k -= index * jiecheng;
            jiecheng /= i;
            ans += num[index];
            num.erase(num.begin() + index);
        }
        ans += num[0];
        return ans;
    }
};

//Rotate List 
class Solution {
public:
    ListNode *rotateRight(ListNode *head, int k) {
        if(head == NULL)
            return head;
        ListNode *p1 = head;
        int n = 0;
        while(p1 != NULL) {
            p1 = p1->next;
            n++;
        }
        k %= n;
        if(k == 0)
            return head;
        ListNode *newHead = new ListNode(0);
        newHead->next = head;
        p1 = newHead;
        ListNode *p2 = newHead;
        for(int i = 0; i < k; i++)
            p2 = p2->next;
        while(p2->next != NULL) {
            p1 = p1->next;
            p2 = p2->next;
        }
        newHead->next = p1->next;
        p1->next = NULL;
        p2->next = head;
        p1 = newHead->next;
        delete[] newHead;
        return p1;
    }
};

//Implement strStr() 
class Solution {
public:
    char *strStr(char *haystack, char *needle) {
        int len1 = strlen(haystack);
        int len2 = strlen(needle);
        vector<int> next(len2 + 1, 0);
        get_next(needle, next);
        int i = 0;
        int j = 0;
        while(i < len1 && j < len2) {
            if(haystack[i] == needle[j]) {
                i++;
                j++;
            }
            else if(j == 0) {
                i++;
            }
            else {
                j = next[j-1] + 1;
            }
        }
        if(j == len2) {
            return haystack + i - j;
        }
        return NULL;
    }
    void get_next(char *s, vector<int> &next) {
        int len = strlen(s);
        next[0] = -1;
        int j = -1;
        for(int i = 1; i < len; i++) {
            while(j >= 0 && s[i] != s[j+1])
                j = next[j];
            if(s[i] == s[j+1]) 
                j = j + 1;
            next[i] = j;
        }
    }
};

//Merge k Sorted Lists 
struct cmp {
     bool operator() (const ListNode *a, const ListNode *b) {
         return a->val >= b->val;
     }
};
class Solution {
public:
    ListNode *mergeKLists(vector<ListNode *> &lists) {
        int n = lists.size();
        priority_queue<ListNode *, vector<ListNode*>, cmp> q;
        for(int i = 0; i < n; i++) {
            if(lists[i])
                q.push(lists[i]);
        }
        ListNode *newHead = new ListNode(0);
        ListNode *p = newHead;
        while(!q.empty()) {
            p->next = q.top();
            q.pop();
            p = p->next;
            if(p->next)
                q.push(p->next);
        }
        p = newHead->next;
        delete[] newHead;
        return p;
    }
};

//4Sum 
class Solution {
public:
    vector<vector<int> > fourSum(vector<int> &num, int target) {
        sort(num.begin(), num.end());
        vector<vector<int> > ans;
        int n = num.size();
        for(int k = 0; k < n - 3; k++) {
            if(k > 0 && num[k] == num[k-1])
                continue;
            for(int kk = k + 1; kk < n - 2; kk++) {
                if(kk > k + 1 && num[kk] == num[kk-1])
                    continue;
                int i = kk + 1;
                int j = n - 1;
                while(i < j) {
                    while(i > kk + 1 && num[i] == num[i-1])
                        i++;
                    while(i < j && num[i] + num[j] >= target - num[k] - num[kk])
                        j--;
                    if(j < n - 1 && num[i] + num[j+1] == target - num[k] - num[kk]) {
                        vector<int> tmp;
                        tmp.push_back(num[k]);
                        tmp.push_back(num[kk]);
                        tmp.push_back(num[i]);
                        tmp.push_back(num[j+1]);
                        ans.push_back(tmp);
                    }
                    i++;
                }
            }
        }
        return ans;
    }
};

//Maximal Rectangle 
class Solution {
public:
    int maximalRectangle(vector<vector<char> > &matrix) {
        int n = matrix.size();
        if(n == 0)
            return 0;
        int m = matrix[0].size();
        vector<vector<int> > height(n + 1, vector<int>(m + 1, 0));
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                if(matrix[i][j] == '1')
                    height[i+1][j] = height[i][j] + 1;
            }
        }
        int ans = 0;
        for(int i = 1; i <= n; i++) {
            stack<int> inc_que_index;
            inc_que_index.push(0);
            for(int j = 1; j <= m; j++) {
                int start = j;
                while(!inc_que_index.empty() && height[i][j] < height[i][inc_que_index.top()]) {
                    start = inc_que_index.top();
                    ans = max(ans, height[i][start] * (j - start));
                    inc_que_index.pop();
                }
                if(inc_que_index.empty() || height[i][j] > height[i][inc_que_index.top()]) {
                    inc_que_index.push(start);
                    height[i][start] = height[i][j];
                }   
            }
        }
        return ans;
    }
};

//Largest Rectangle in Histogram 
class Solution {
public:
    int largestRectangleArea(vector<int> &height) {
        vector<int> v(height);
        v.push_back(0);
        stack<int> inc_que_index;
        inc_que_index.push(0);
        int ans = 0;
        for(int i = 1; i < v.size(); i++) {
            int start = i;
            while(!inc_que_index.empty() && v[i] < v[inc_que_index.top()]) {
                start = inc_que_index.top();
                ans = max(ans, v[start] * (i - start));
                inc_que_index.pop();
            }
            if(inc_que_index.empty() || v[i] > v[inc_que_index.top()]) {
                inc_que_index.push(start);
                v[start] = v[i];
            }
        }
        return ans;
    }
};

//Merge Intervals
bool cmp(const Interval &a, const Interval &b) {
    return a.start < b.start;
}
class Solution {
public:
    vector<Interval> merge(vector<Interval> &intervals) {
		sort(intervals.begin(), intervals.end(), cmp);
        vector<Interval> ans;
        if(intervals.size() == 0)
            return ans;
        Interval tmp = intervals[0];
        for(int i = 1; i < intervals.size(); i++) {
            if(tmp.end >= intervals[i].start) {
                tmp.end = max(tmp.end, intervals[i].end);
                continue;
            }
            ans.push_back(tmp);
            tmp = intervals[i];
        }
        ans.push_back(tmp);
        return ans;
    }
};

//Word Break
class Solution {
public:
    bool wordBreak(string s, unordered_set<string> &dict) {
        unordered_set<string> unmatch;
        return go(s, dict, unmatch);
    }
    bool go(string s, const unordered_set<string> &dict, unordered_set<string> &unmatch) {
        if(dict.find(s) != dict.end())
            return true;
        for(int i = 1; i <= s.size(); i++) {
            if(dict.find(s.substr(0, i)) != dict.end()) {
                if(unmatch.find(s.substr(i)) != unmatch.end())
                    continue;
                if(go(s.substr(i), dict, unmatch) == false)
                    unmatch.insert(s.substr(i));
                else
                    return true;
            }
        }
        return false;
    }
};

//Insert Interval
class Solution {
public:
    vector<Interval> insert(vector<Interval> &intervals, Interval newInterval) {
        vector<Interval> ans;
        bool flag = false;
        for(int i = 0; i < intervals.size(); i++) {
            if(newInterval.start > intervals[i].end)
                ans.push_back(intervals[i]);
            else if(newInterval.end < intervals[i].start) {
                if(flag == false) {
                    ans.push_back(newInterval);
                    flag = true;
                }
                ans.push_back(intervals[i]);
            }
            else if(newInterval.end >= intervals[i].start) {
                newInterval.start = min(newInterval.start, intervals[i].start);
                newInterval.end = max(newInterval.end, intervals[i].end);
            }
        }
        if(flag == false)
            ans.push_back(newInterval);
        return ans;
    }
};

//Spiral Matrix 
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int> > &matrix) {
        vector<int> ans;
        if(matrix.empty())
            return ans;
        int endM = matrix.size() - 1;
        int endN = matrix[0].size() - 1;
        int startM = 0;
        int startN = 0;
        while(true) {
            for(int i = startN; i <= endN; i++)
                ans.push_back(matrix[startM][i]);
            if(++startM > endM)
                break;
            for(int i = startM; i <= endM; i++)
                ans.push_back(matrix[i][endN]);
            if(--endN < startN)
                break;
            for(int i = endN; i >= startN; i--)
                ans.push_back(matrix[endM][i]);
            if(--endM < startM)
                break;
            for(int i = endM; i >= startM; i--)
                ans.push_back(matrix[i][startN]);
            if(++startN > endN)
                break;
        }
        return ans;
    }
};

//Sort List
class Solution {
public:
    ListNode *sortList(ListNode *head) {
        if(head == NULL)
            return NULL;
        int len = 1;
        for(ListNode *p = head->next; p != NULL && p != head; p = p->next)
            len++;
        return mergeSortList(head, len);
    }
    ListNode *mergeSortList(ListNode *head, int len) {
        if(len <= 1)
            return head;
        int len1 = len >> 1;
        ListNode *p = head;
        for(int i = 0; i < len1; i++)
            p = p->next;
        ListNode *p1 = mergeSortList(head, len1);
        ListNode *p2 = mergeSortList(p, len - len1);
        ListNode *new_head = new ListNode(0);
        p = new_head;
        for(int i = 0, j = 0; i < len1 || j < len - len1;) {
            if(j < len - len1 && (i == len1 || p1->val > p2->val)) {
                p->next = p2;
				p = p->next;
                p2 = p2->next;
                j++;
            }
            if(i < len1 && (j == len - len1 || p1->val <= p2->val)) {
                p->next = p1;
				p = p->next;
                p1 = p1->next;
                i++;
            }
        }
		p->next = NULL;
        p = new_head->next;
        delete[] new_head;
        return p;
    }
};

//Two Sum
class Solution {
public:
    vector<int> twoSum(vector<int> &numbers, int target) {
        multimap<int, int> m;
        for(int i = 0; i < numbers.size(); i++) 
            m.insert(make_pair(numbers[i], i+1));
        multimap<int, int>::iterator it1 = m.begin(), it2 = m.end();
        it2--;
        vector<int> ans(2, 0);
        while(it1 != it2) {
            int num = it1->first + it2->first;
            if(num > target)
                it2--;
            else if(num < target)
                it1++;
            else break;
        }
        ans[0] = min(it1->second, it2->second);
        ans[1] = max(it1->second, it2->second);
        return ans;
    }
};

//Generate Parentheses
class Solution {
public:
    vector<string> generateParenthesis(int n) {
        vector<string> ans;
        string cur = "";
        go(ans, cur, n, n);
        return ans;
    }
    void go(vector<string> &ans, string cur, int nl, int nr) {
        if(nl < nr) {
            if(nl != 0) {
                go(ans, cur + "(", nl-1, nr);
            }
            go(ans, cur + ")", nl, nr - 1);
        }
        else {
            if(nl == 0) {
                ans.push_back(cur);
                return;
            }
            go(ans, cur + "(", nl-1, nr);
        }
    }
};

//Sudoku Solver
class Solution {
public:
    bool solveSudoku(vector<vector<char> > &board) {
        for(int i = 0; i < 9; i++) {
            for(int j = 0; j < 9; j++) {
                if(board[i][j] == '.') {
                    for(int k = 1; k <=9; k++) {
                        board[i][j] = '0' + k;
                        if(isValid(board, i, j) && solveSudoku(board))
                            return true;
                        board[i][j] = '.';
                    }
                    return false;
                }
            }
        }
        return true;
    }
private:
    bool isValid(const vector<vector<char> > &board, int x, int y) {
        for(int i = 0; i < 9; i++)
            if(i != x && board[i][y] == board[x][y])
                return false;
        for(int j = 0; j < 9; j++)
            if(j != y && board[x][j] == board[x][y])
                return false;
        for(int i = 3 * (x / 3); i < 3 * (x / 3 + 1); i++) 
            for(int j = 3 * (y / 3); j < 3 * (y / 3 + 1); j++)
                if((i != x || j != y) && board[i][j] == board[x][y])
                    return false;
        return true;
    }
};

//Reverse Words in a String
class Solution {
public:
    void reverseWords(string &s) {
        stack<string> word_stack;
        string word = "";
        s += ' ';
        for(int i = 0; i < s.length(); i++) {
            if(s[i] == ' ') {
                if(word != "")
                    word_stack.push(word);
                word = "";
            }
            else
                word += s[i];
        }
        string ans = "";
        while(!word_stack.empty()) {
            if(ans != "")
                ans += " ";
            ans += word_stack.top();
            word_stack.pop();
        }
        s = ans;
    }
};

//
