//Fight!

//Single Number
class Solution {
public:
    int singleNumber(int A[], int n) {
        int ans=0;
        for(int i=0;i<n;i++)
            ans=ans^A[i];
        return ans;
    }
};

//Maximum Depth of Binary Tree
class Solution {
public:
    int maxDepth(TreeNode *root) {
        int max_depth=0;
        go(root,0,max_depth);
        return max_depth;
    }
    void go(TreeNode *node,int depth, int &max_depth) {
        if(node!=NULL) {
            depth++;
            if(depth>max_depth)
                max_depth=depth;
            go(node->left,depth,max_depth);
            go(node->right,depth,max_depth);
        }
    }
};

//Same Tree
class Solution {
public:
    bool isSameTree(TreeNode *node1, TreeNode *node2) {
         if(node1!=NULL && node2==NULL)
            return false;
        else if(node1==NULL && node2!=NULL)
            return false;
        else if(node1!=NULL && node2!=NULL) {
            if(node1->val!=node2->val)
                return false;
            else
                return isSameTree(node1->left,node2->left) && isSameTree(node1->right,node2->right);
        }
        return true;
    }
};

//Reverse Integer
class Solution {
public:
    int reverse(int x) {
       int ans=0;
        while(x) {
        	ans=ans*10+x%10;
            x/=10;
        }
        return ans;
    }
};

//Best Time to Buy and Sell Stock II
class Solution {
public:
    int maxProfit(vector<int> &prices) {
        int n=prices.size();
        if(n==0)
            return 0;
        int buy=prices[0];
        int ans=0;
        for(int i=1;i<n;i++) {
            if(prices[i]>buy)
                ans+=prices[i]-buy;
            buy=prices[i];
        }
        return ans;
    }
};

//Linked List Cycle 
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* one=head;
        ListNode* two=head;
        while(two!=NULL) {
            if(one->next!=NULL)
                one=one->next;
            if(two->next!=NULL && two->next->next!=NULL)
                two=two->next->next;
            else
                return false;
            if(one==two)
                return true;
        }
    }
};

//Unique Binary Search Trees
class Solution {
public:
    int numTrees(int n) {
        if(n==0)
            return 1;
        int ans=0;
        for(int i=1;i<=n;i++)
            ans+=numTrees(i-1)*numTrees(n-i);
        return ans;    
    }
};

//Populating Next Right Pointers in Each Node 
/**
 * Definition for binary tree with next pointer.
 * struct TreeLinkNode {
 *  int val;
 *  TreeLinkNode *left, *right, *next;
 *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
 * };
 */
class Solution {
public:
    void connect(TreeLinkNode *root) {
        if(root==NULL)
            return ;
        if(root->left!=NULL && root->right!=NULL)
            root->left->next=root->right;
        if(root->left!=NULL && root->next!=NULL)
            root->right->next=root->next->left;
        connect(root->left);
        connect(root->right);
    }
};

//Search Insert Position
class Solution {
public:
    int searchInsert(int A[], int n, int target) {
        int i=0,j=n-1;
        while(i<=j) {
            int mid=(i+j)/2;
            if(target<=A[mid])
                j=mid-1;
            else
                i=mid+1;
        }
        return i;
    }
};

//Remove Duplicates from Sorted List
class Solution {
public:
    ListNode *deleteDuplicates(ListNode *head) {
        ListNode* ans=head;
        if(head==NULL)
            return ans;
        while(head->next!=NULL) {
            if(head->val==head->next->val) {
                ListNode* tmp=head->next;
                head->next=tmp->next;
                delete(tmp);
            }
            else
                head=head->next;
        }
        return ans;
    }
};

//Binary Tree Inorder Traversal 
class Solution {
public:
    vector<int> inorderTraversal(TreeNode *root) {
        vector<int> ans;
        if(root!=NULL)
            inorderTravel(root,ans);
        return ans;
    }
    void inorderTravel(TreeNode *node, vector<int> &v) {
        if(node->left!=NULL)
            inorderTravel(node->left,v);
        v.push_back(node->val);
        if(node->right!=NULL)
            inorderTravel(node->right,v);
    }
};

//Binary Tree Preorder Traversal
class Solution {
public:
    vector<int> preorderTraversal(TreeNode *root) {
        vector<int> ans;
        if(root!=NULL)
            preorderTravel(root,ans);
        return ans;
    }
    void preorderTravel(TreeNode *node, vector<int> &v) {
        v.push_back(node->val);
        if(node->left!=NULL)
            preorderTravel(node->left,v);
        if(node->right!=NULL)
            preorderTravel(node->right,v);
    }
};

//Climbing Stairs
class Solution {
public:
    int climbStairs(int n) {
        int a[2]={1,1},k;
        for(k=2;k<=n;k++) {
            a[k%2]=a[0]+a[1];
        }
        return a[(k+1)%2];
    }
};

//Remove Element
class Solution {
public:
    int removeElement(int A[], int n, int elem) {
        int i=0,j=n-1;
        while(i<=j) {
            while(i<n && A[i]!=elem)
                i++;
            while(j>=0 && A[j]==elem)
                j--;
            if(i>j)
                break;
            int t=A[i];
            A[i++]=A[j];
            A[j--]=t;
        }
        return i;
    }
};

//Remove Duplicates from Sorted Array
class Solution {
public:
    int removeDuplicates(int A[], int n) {
        if(n==0)
            return 0;
        int i=1;
        while(i<n && A[i-1]<A[i])
            i++;
        int j=i+1;
        while(j<n) {
            while(j<n && A[j]<=A[j-1])
                j++;
            if(j>=n)
                break;
            A[i++]=A[j++];
        }
        return i;
    }
};

//Maximum Subarray 
class Solution {
public:
    int maxSubArray(int A[], int n) {
        int ans=A[0],tmp=A[0];
        for(int i=1;i<n;i++) {
            tmp=(tmp<0) ? 0 : tmp;
            tmp+=A[i];
            ans=(tmp>ans) ? tmp : ans;
        }
        return ans;
    }
};

//Symmetric Tree 
class Solution {
public:
    bool isSymmetric(TreeNode *root) {
        if(root!=NULL)
            return isSame(root->left, root->right);
        return true;
    }
    bool isSame(TreeNode *node1, TreeNode *node2) {
        if(node1==NULL && node2==NULL)
            return true;
        if(node1!=NULL && node2==NULL)
            return false;
        if(node1==NULL && node2!=NULL)
            return false;
        if(node1->val!=node2->val)
            return false;
        return isSame(node1->left,node2->right) 
            && isSame(node1->right, node2->left);
    }
};

//Merge Two Sorted Lists
class Solution {
public:
    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {
        if(l2==NULL)
            return l1;
        if(l1==NULL)
            return l2;
        ListNode *ans=l1;
        if(l1->val > l2->val) {
            l1=l2;
            l2=ans;
            ans=l1;
        }
        while(l1->next!=NULL && l2!=NULL) {
            if(l1->next->val > l2->val) {
                ListNode *t1=l1->next;
                ListNode *t2=l2->next;
                l1->next=l2;
                l2->next=t1;
                l1=l2;
                l2=t2;
            }
            else
                l1=l1->next;
        }
        if(l2!=NULL)
            l1->next=l2;
        return ans;
    }
};

//Convert Sorted Array to Binary Search Tree
/**
 * Definition for binary tree
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode *sortedArrayToBST(vector<int> &num) {
        int n=num.size();
        if(n==0) 
            return NULL;
        TreeNode *root=new TreeNode(0);
        construct(num,0,n-1,root);
        return root;
    }
    void construct(vector<int> &num, int i, int j, TreeNode *node) {
        int mid=(i+j)/2;
        node->val=num[mid];
        if(i<mid) {
            TreeNode *l=new TreeNode(0);
            node->left=l;
            construct(num,i,mid-1,l);
        }
        if(j>mid) {
            TreeNode *r=new TreeNode(0);
            node->right=r;
            construct(num,mid+1,j,r);
        }
    }
};

//Next Permutation 
class Solution {
public:
    void nextPermutation(vector<int> &num) {
        const int n=num.size();
        int start=n-1;
        while(start>0 && num[start]<=num[start-1])
            start--;
        if(start>0) {
            int index=start;
            for(int i=start+1;i<n;i++)
                if(num[i]>num[start-1] && num[i]<num[index])
                    index=i;
            int tmp=num[index];
            num[index]=num[start-1];
            num[start-1]=tmp;
        }
        sort(num,start,n-1);
    }
    void sort(vector<int> &num,int s,int e) {
        if(s>=e)
            return;
        int i=s+1;
        int j=e;
        while(i<=j) {
            while(i<=e && num[i]<=num[s])
                i++;
            while(j>=s && num[j]>num[s])
                j--;
            if(i>=j)
                break;
            int t=num[i];
            num[i]=num[j];
            num[j]=t;
        }
        int t=num[s];
        num[s]=num[j];
        num[j]=t;
        if(j-1>s)
            sort(num,s,j-1);
        if(i<e)
            sort(num,i,e);
    }
};

//Merge Sorted Array
class Solution {
public:
    void merge(int A[], int m, int B[], int n) {
        int k=m+n-1;
        int i=m-1;
        int j=n-1;
        while(i>=0 && j>=0) {
            if(A[i]>=B[j]) 
                A[k--]=A[i--];
            else
                A[k--]=B[j--];
        }
        if(i<0) {
            while(j>=0)
                A[k--]=B[j--];
        }
    }
};

//Submission Details
class Solution {
public:
    ListNode *swapPairs(ListNode *head) {
        if(head==NULL || head->next==NULL)
            return head;
        ListNode *cur=head;
        head=head->next;
        cur->next=head->next;
        head->next=cur;
        ListNode *tmp;
        while(cur->next!=NULL && cur->next->next!=NULL) {
            tmp=cur->next;
            cur->next=tmp->next;
            tmp->next=cur->next->next;
            cur->next->next=tmp;
            cur=tmp;
        }
        return head;
    }
};

//Pascal's Triangle
class Solution {
public:
    vector<vector<int> > generate(int numRows) {
        vector<vector<int> > ans;
        for(int i=0;i<numRows;i++) {
            vector<int> cur;
            cur.push_back(1);
            for(int j=1;j<i;j++) 
                cur.push_back(ans[i-1][j-1]+ans[i-1][j]);
            if(i>0)
                cur.push_back(1);
            ans.push_back(cur);
        }
        return ans;
    }
};

//Best Time to Buy and Sell Stock 
class Solution {
public:
    int maxProfit(vector<int> &prices) {
        int n=prices.size();
        int ans=0,tmp=0;
        for(int i=1;i<n;i++) {
            tmp+=prices[i]-prices[i-1];
            if(tmp>ans)
                ans=tmp;
            if(tmp<0)
                tmp=0;
        }
        return ans;
    }
};

//Balanced Binary Tree
class Solution {
public:
    bool isBalanced(TreeNode *root) {
        if(root==NULL)
            return true;
        int c=height(root->left)-height(root->right);
        if(c>=-1 && c<=1 && isBalanced(root->left) && isBalanced(root->right))
            return true;
        return false;
    }
    int height(TreeNode *node) {
        if(node==NULL)
            return 0;
        return max(height(node->left),height(node->right))+1;
    }
};

//Gray Code
class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> ans;
        ans.push_back(0);
        int k=1;
        for(int i=0;i<n;i++) {
            for(int j=k-1;j>=0;j--) 
                ans.push_back(ans[j]+k);
            k=k<<1;
        }
        return ans;
    }
};

//Binary Tree Level Order Traversal II 
class Solution {
public:
    vector<vector<int> > levelOrderBottom(TreeNode *root) {
        vector<vector<int> > ans;
        if(root==NULL)
            return ans;
        queue<TreeNode*> level;
        int width=1;
        level.push(root);
        while(!level.empty()) {
            int num=0;
            vector<int> v;
            for(int i=0;i<width;i++) {
                TreeNode *node=level.front();
                level.pop();
                v.push_back(node->val);
                if(node->left!=NULL) {
                    level.push(node->left);
                    num++;
                }
                if(node->right!=NULL) {
                    level.push(node->right);
                    num++;
                }
            }
            width=num;
            ans.push_back(v);
        }
        int n=ans.size()-1;
        vector<vector<int> > fin_ans;
        while(n>=0) 
            fin_ans.push_back(ans[n--]);
        return fin_ans;
    }
};

//Permutations 
class Solution {
public:
    vector<vector<int> > permute(vector<int> &num) {
        vector<vector<int> > ans;
        int n=num.size();
        go(ans,num,n,0);
        return ans;
    }
    void go(vector<vector<int> > &ans,vector<int> &num, int n,int k) {
        if(k==n) {
            ans.push_back(num);
            return;
        }
        for(int i=k;i<n;i++) {
            swap(num,i,k);
            go(ans,num,n,k+1);
            swap(num,i,k);
        }
    }
    void swap(vector<int> &num, int i, int k) {
        int tmp=num[i];
        num[i]=num[k];
        num[k]=tmp;
    }
};

//Minimum Path Sum 
class Solution {
public:
    int minPathSum(vector<vector<int> > &grid) {
        int m=grid.size();
        int n=grid[0].size();
        vector<int> v;
        int tmp=0;
        for(int i=0;i<n;i++) {
            tmp+=grid[0][i];
            v.push_back(tmp);
        }
        for(int i=1;i<m;i++) {
            v[0]+=grid[i][0];
            for(int j=1;j<n;j++) 
                v[j]=min(v[j],v[j-1])+grid[i][j];
        }
        return v[n-1];
    }
};

//Single Number II
class Solution {
public:
    int singleNumber(int A[], int n) {
        int bits[32];
        memset(bits,0,sizeof(bits));
        for(int i=0;i<n;i++) {
            int num=A[i];
            int k=0;
            for(int j=0;j<32;j++) {
                bits[k++]+=num&1;
                num=num>>1;
            }
        }
        int ans=0;
        long long k=1;
        for(int i=0;i<31;i++) {
            bits[i]%=3;
            if(bits[i]!=0)
                ans+=k;
            k=k<<1;
        }
        if(bits[31]%3!=0)
            ans=(long long)ans-k;
        return ans;
    }
};

//Unique Paths 
class Solution {
public:
    int uniquePaths(int m, int n) {
        int a[105];
        for(int i=0;i<n;i++)
            a[i]=1;
        for(int i=1;i<m;i++)
            for(int j=1;j<n;j++)
                a[j]=a[j]+a[j-1];
        return a[n-1];
    }
};

//Rotate Image 
class Solution {
public:
    void rotate(vector<vector<int> > &matrix) {
        int n=matrix.size();
        for(int i=0;i<n/2;i++) {
            for(int j=i;j<n-i-1;j++) {
                int tmp=matrix[i][j];
                matrix[i][j]=matrix[n-1-j][i];
                matrix[n-1-j][i]=matrix[n-1-i][n-1-j];
                matrix[n-1-i][n-1-j]=matrix[j][n-1-i];
                matrix[j][n-1-i]=tmp;
            }
        }
    }
};

//Linked List Cycle II 
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode *oneStep=head;
        ListNode *twoStep=head;
        while(twoStep!=NULL) {
            if(oneStep->next!=NULL)
                oneStep=oneStep->next;
            if(twoStep->next!=NULL && twoStep->next->next!=NULL)
                twoStep=twoStep->next->next;
            else
                return NULL;
            if(oneStep==twoStep) 
                break;
        }
        ListNode *start=head;
        while(1) {
            if(start==oneStep)
                return start;
            oneStep=oneStep->next;
            while(oneStep!=twoStep) {
                if(start==oneStep)
                    return start;
                oneStep=oneStep->next;
            }
            start=start->next;
        }
    }
};

//Search a 2D Matrix 
class Solution {
public:
    bool searchMatrix(vector<vector<int> > &matrix, int target) {
        int m=matrix.size();
        int n=matrix[0].size();
        int i=0;
        int j=m-1;
        while(i<=j) {
            int mid=(i+j)/2;
            if(matrix[mid][0]<=target)
                i=mid+1;
            else
                j=mid-1;
        }
        if(j<0)
            return false;
        int ii=0;
        int jj=n-1;
        while(ii<=jj) {
            int mid=(ii+jj)/2;
            if(matrix[j][mid]<=target)
                ii=mid+1;
            else
                jj=mid-1;
        }
        if(jj<0)
            return false;
        if(matrix[j][jj]==target)
            return true;
    }
};

//Plus One class Solution {
public:
    vector<int> plusOne(vector<int> &digits) {
        vector<int> ans;
        int n=digits.size()-1;
        while(n>=0 && digits[n]==9) {
            ans.insert(ans.begin(),0);
            n--;
        }
        if(n<0)
            ans.insert(ans.begin(),1);
        else {
            ans.insert(ans.begin(),digits[n--]+1);
            while(n>=0)
                ans.insert(ans.begin(),digits[n--]);
        }
        return ans;
    }
};

//Jump Game
class Solution {
public:
    bool canJump(int A[], int n) {
        int maxx=0;
        for(int i=0;i<n;i++) {
            if(i>maxx)
                break;
            maxx=(maxx>=A[i]+i) ? maxx : A[i]+i;
            if(maxx>=n-1)
                return true;
        }
        return false;
    }
};

//Binary Tree Postorder Traversal 
class Solution {
public:
    vector<int> postorderTraversal(TreeNode *root) {
        vector<int> ans;
        if(root!=NULL)
            postTravel(root,ans);
        return ans;
    }
    void postTravel(TreeNode *node, vector<int> &ans) {
        if(node->left!=NULL)
            postTravel(node->left,ans);
        if(node->right!=NULL)
            postTravel(node->right,ans);
        ans.push_back(node->val);
    }
};

//Binary Tree Level Order Traversal 
class Solution {
public:
    vector<vector<int> > levelOrder(TreeNode *root) {
        vector<vector<int> > ans;
        if(root==NULL)
            return ans;
        queue<TreeNode*> level;
        int width=1;
        level.push(root);
        while(!level.empty()) {
            int num=0;
            vector<int> v;
            for(int i=0;i<width;i++) {
                TreeNode *node=level.front();
                level.pop();
                v.push_back(node->val);
                if(node->left!=NULL) {
                    level.push(node->left);
                    num++;
                }
                if(node->right!=NULL) {
                    level.push(node->right);
                    num++;
                }
            }
            width=num;
            ans.push_back(v);
        }
        return ans;
    }
};

//Jump Game II
class Solution {
public:
    int jump(int A[], int n) {
        if(n<=1)
            return 0;
        int next_s=0;
        int ans_e=0;
        int ans=0;
        for(int i=0;i<n;i++) {
            if(i>=next_s) {
                next_s=ans_e+1;
                ans++;
            }
            if(i+A[i]>ans_e) 
                ans_e=i+A[i];
            if(ans_e>=n-1)
                return ans;
        }
    }
};

//
